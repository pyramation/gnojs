import * as _18 from "../github.com/gnolang/gno/pkgs/bft/abci/types/abci";
export declare const abci: {
    RequestBase: {
        encode(_: _18.RequestBase, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.RequestBase;
        fromJSON(_: any): _18.RequestBase;
        toJSON(_: _18.RequestBase): unknown;
        fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): _18.RequestBase;
    };
    RequestEcho: {
        encode(message: _18.RequestEcho, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.RequestEcho;
        fromJSON(object: any): _18.RequestEcho;
        toJSON(message: _18.RequestEcho): unknown;
        fromPartial<I_1 extends {
            RequestBase?: {};
            Message?: string;
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_1["RequestBase"], never>, never>;
            Message?: string;
        } & Record<Exclude<keyof I_1, keyof _18.RequestEcho>, never>>(object: I_1): _18.RequestEcho;
    };
    RequestFlush: {
        encode(message: _18.RequestFlush, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.RequestFlush;
        fromJSON(object: any): _18.RequestFlush;
        toJSON(message: _18.RequestFlush): unknown;
        fromPartial<I_2 extends {
            RequestBase?: {};
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_2["RequestBase"], never>, never>;
        } & Record<Exclude<keyof I_2, "RequestBase">, never>>(object: I_2): _18.RequestFlush;
    };
    RequestInfo: {
        encode(message: _18.RequestInfo, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.RequestInfo;
        fromJSON(object: any): _18.RequestInfo;
        toJSON(message: _18.RequestInfo): unknown;
        fromPartial<I_3 extends {
            RequestBase?: {};
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_3["RequestBase"], never>, never>;
        } & Record<Exclude<keyof I_3, "RequestBase">, never>>(object: I_3): _18.RequestInfo;
    };
    RequestSetOption: {
        encode(message: _18.RequestSetOption, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.RequestSetOption;
        fromJSON(object: any): _18.RequestSetOption;
        toJSON(message: _18.RequestSetOption): unknown;
        fromPartial<I_4 extends {
            RequestBase?: {};
            Key?: string;
            Value?: string;
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_4["RequestBase"], never>, never>;
            Key?: string;
            Value?: string;
        } & Record<Exclude<keyof I_4, keyof _18.RequestSetOption>, never>>(object: I_4): _18.RequestSetOption;
    };
    RequestInitChain: {
        encode(message: _18.RequestInitChain, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.RequestInitChain;
        fromJSON(object: any): _18.RequestInitChain;
        toJSON(message: _18.RequestInitChain): unknown;
        fromPartial<I_5 extends {
            RequestBase?: {};
            Time?: Date;
            ChainID?: string;
            ConsensusParams?: {
                Block?: {
                    MaxTxBytes?: string | number | import("long");
                    MaxDataBytes?: string | number | import("long");
                    MaxBlockBytes?: string | number | import("long");
                    MaxGas?: string | number | import("long");
                    TimeIotaMS?: string | number | import("long");
                };
                Validator?: {
                    PubKeyTypeURLs?: string[];
                };
            };
            Validators?: {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            }[];
            AppState?: {
                typeUrl?: string;
                value?: Uint8Array;
            };
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_5["RequestBase"], never>, never>;
            Time?: Date;
            ChainID?: string;
            ConsensusParams?: {
                Block?: {
                    MaxTxBytes?: string | number | import("long");
                    MaxDataBytes?: string | number | import("long");
                    MaxBlockBytes?: string | number | import("long");
                    MaxGas?: string | number | import("long");
                    TimeIotaMS?: string | number | import("long");
                };
                Validator?: {
                    PubKeyTypeURLs?: string[];
                };
            } & {
                Block?: {
                    MaxTxBytes?: string | number | import("long");
                    MaxDataBytes?: string | number | import("long");
                    MaxBlockBytes?: string | number | import("long");
                    MaxGas?: string | number | import("long");
                    TimeIotaMS?: string | number | import("long");
                } & {
                    MaxTxBytes?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_5["ConsensusParams"]["Block"]["MaxTxBytes"], keyof import("long")>, never>);
                    MaxDataBytes?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_5["ConsensusParams"]["Block"]["MaxDataBytes"], keyof import("long")>, never>);
                    MaxBlockBytes?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_5["ConsensusParams"]["Block"]["MaxBlockBytes"], keyof import("long")>, never>);
                    MaxGas?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_5["ConsensusParams"]["Block"]["MaxGas"], keyof import("long")>, never>);
                    TimeIotaMS?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_5["ConsensusParams"]["Block"]["TimeIotaMS"], keyof import("long")>, never>);
                } & Record<Exclude<keyof I_5["ConsensusParams"]["Block"], keyof _18.BlockParams>, never>;
                Validator?: {
                    PubKeyTypeURLs?: string[];
                } & {
                    PubKeyTypeURLs?: string[] & string[] & Record<Exclude<keyof I_5["ConsensusParams"]["Validator"]["PubKeyTypeURLs"], keyof string[]>, never>;
                } & Record<Exclude<keyof I_5["ConsensusParams"]["Validator"], "PubKeyTypeURLs">, never>;
            } & Record<Exclude<keyof I_5["ConsensusParams"], keyof _18.ConsensusParams>, never>;
            Validators?: {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            }[] & ({
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            } & {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_5["Validators"][number]["PubKey"], keyof import("../google/protobuf/any").Any>, never>;
                Power?: string | number | (import("long") & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long")) => import("long");
                    and: (other: string | number | import("long")) => import("long");
                    compare: (other: string | number | import("long")) => number;
                    comp: (other: string | number | import("long")) => number;
                    divide: (divisor: string | number | import("long")) => import("long");
                    div: (divisor: string | number | import("long")) => import("long");
                    equals: (other: string | number | import("long")) => boolean;
                    eq: (other: string | number | import("long")) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long")) => boolean;
                    gt: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                    gte: (other: string | number | import("long")) => boolean;
                    ge: (other: string | number | import("long")) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    eqz: () => boolean;
                    lessThan: (other: string | number | import("long")) => boolean;
                    lt: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual: (other: string | number | import("long")) => boolean;
                    lte: (other: string | number | import("long")) => boolean;
                    le: (other: string | number | import("long")) => boolean;
                    modulo: (other: string | number | import("long")) => import("long");
                    mod: (other: string | number | import("long")) => import("long");
                    rem: (other: string | number | import("long")) => import("long");
                    multiply: (multiplier: string | number | import("long")) => import("long");
                    mul: (multiplier: string | number | import("long")) => import("long");
                    negate: () => import("long");
                    neg: () => import("long");
                    not: () => import("long");
                    countLeadingZeros: () => number;
                    clz: () => number;
                    countTrailingZeros: () => number;
                    ctz: () => number;
                    notEquals: (other: string | number | import("long")) => boolean;
                    neq: (other: string | number | import("long")) => boolean;
                    ne: (other: string | number | import("long")) => boolean;
                    or: (other: string | number | import("long")) => import("long");
                    shiftLeft: (numBits: number | import("long")) => import("long");
                    shl: (numBits: number | import("long")) => import("long");
                    shiftRight: (numBits: number | import("long")) => import("long");
                    shr: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                    shru: (numBits: number | import("long")) => import("long");
                    shr_u: (numBits: number | import("long")) => import("long");
                    rotateLeft: (numBits: number | import("long")) => import("long");
                    rotl: (numBits: number | import("long")) => import("long");
                    rotateRight: (numBits: number | import("long")) => import("long");
                    rotr: (numBits: number | import("long")) => import("long");
                    subtract: (subtrahend: string | number | import("long")) => import("long");
                    sub: (subtrahend: string | number | import("long")) => import("long");
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long");
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long");
                    xor: (other: string | number | import("long")) => import("long");
                } & Record<Exclude<keyof I_5["Validators"][number]["Power"], keyof import("long")>, never>);
            } & Record<Exclude<keyof I_5["Validators"][number], keyof _18.ValidatorUpdate>, never>)[] & Record<Exclude<keyof I_5["Validators"], keyof {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            }[]>, never>;
            AppState?: {
                typeUrl?: string;
                value?: Uint8Array;
            } & {
                typeUrl?: string;
                value?: Uint8Array;
            } & Record<Exclude<keyof I_5["AppState"], keyof import("../google/protobuf/any").Any>, never>;
        } & Record<Exclude<keyof I_5, keyof _18.RequestInitChain>, never>>(object: I_5): _18.RequestInitChain;
    };
    RequestQuery: {
        encode(message: _18.RequestQuery, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.RequestQuery;
        fromJSON(object: any): _18.RequestQuery;
        toJSON(message: _18.RequestQuery): unknown;
        fromPartial<I_6 extends {
            RequestBase?: {};
            Data?: Uint8Array;
            Path?: string;
            Height?: string | number | import("long");
            Prove?: boolean;
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_6["RequestBase"], never>, never>;
            Data?: Uint8Array;
            Path?: string;
            Height?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_6["Height"], keyof import("long")>, never>);
            Prove?: boolean;
        } & Record<Exclude<keyof I_6, keyof _18.RequestQuery>, never>>(object: I_6): _18.RequestQuery;
    };
    RequestBeginBlock: {
        encode(message: _18.RequestBeginBlock, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.RequestBeginBlock;
        fromJSON(object: any): _18.RequestBeginBlock;
        toJSON(message: _18.RequestBeginBlock): unknown;
        fromPartial<I_7 extends {
            RequestBase?: {};
            Hash?: Uint8Array;
            Header?: {
                typeUrl?: string;
                value?: Uint8Array;
            };
            LastCommitInfo?: {
                Round?: number;
                Votes?: {
                    Address?: string;
                    Power?: string | number | import("long");
                    SignedLastBlock?: boolean;
                }[];
            };
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_7["RequestBase"], never>, never>;
            Hash?: Uint8Array;
            Header?: {
                typeUrl?: string;
                value?: Uint8Array;
            } & {
                typeUrl?: string;
                value?: Uint8Array;
            } & Record<Exclude<keyof I_7["Header"], keyof import("../google/protobuf/any").Any>, never>;
            LastCommitInfo?: {
                Round?: number;
                Votes?: {
                    Address?: string;
                    Power?: string | number | import("long");
                    SignedLastBlock?: boolean;
                }[];
            } & {
                Round?: number;
                Votes?: {
                    Address?: string;
                    Power?: string | number | import("long");
                    SignedLastBlock?: boolean;
                }[] & ({
                    Address?: string;
                    Power?: string | number | import("long");
                    SignedLastBlock?: boolean;
                } & {
                    Address?: string;
                    Power?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_7["LastCommitInfo"]["Votes"][number]["Power"], keyof import("long")>, never>);
                    SignedLastBlock?: boolean;
                } & Record<Exclude<keyof I_7["LastCommitInfo"]["Votes"][number], keyof _18.VoteInfo>, never>)[] & Record<Exclude<keyof I_7["LastCommitInfo"]["Votes"], keyof {
                    Address?: string;
                    Power?: string | number | import("long");
                    SignedLastBlock?: boolean;
                }[]>, never>;
            } & Record<Exclude<keyof I_7["LastCommitInfo"], keyof _18.LastCommitInfo>, never>;
        } & Record<Exclude<keyof I_7, keyof _18.RequestBeginBlock>, never>>(object: I_7): _18.RequestBeginBlock;
    };
    RequestCheckTx: {
        encode(message: _18.RequestCheckTx, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.RequestCheckTx;
        fromJSON(object: any): _18.RequestCheckTx;
        toJSON(message: _18.RequestCheckTx): unknown;
        fromPartial<I_8 extends {
            RequestBase?: {};
            Tx?: Uint8Array;
            Type?: string | number | import("long");
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_8["RequestBase"], never>, never>;
            Tx?: Uint8Array;
            Type?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_8["Type"], keyof import("long")>, never>);
        } & Record<Exclude<keyof I_8, keyof _18.RequestCheckTx>, never>>(object: I_8): _18.RequestCheckTx;
    };
    RequestDeliverTx: {
        encode(message: _18.RequestDeliverTx, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.RequestDeliverTx;
        fromJSON(object: any): _18.RequestDeliverTx;
        toJSON(message: _18.RequestDeliverTx): unknown;
        fromPartial<I_9 extends {
            RequestBase?: {};
            Tx?: Uint8Array;
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_9["RequestBase"], never>, never>;
            Tx?: Uint8Array;
        } & Record<Exclude<keyof I_9, keyof _18.RequestDeliverTx>, never>>(object: I_9): _18.RequestDeliverTx;
    };
    RequestEndBlock: {
        encode(message: _18.RequestEndBlock, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.RequestEndBlock;
        fromJSON(object: any): _18.RequestEndBlock;
        toJSON(message: _18.RequestEndBlock): unknown;
        fromPartial<I_10 extends {
            RequestBase?: {};
            Height?: string | number | import("long");
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_10["RequestBase"], never>, never>;
            Height?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_10["Height"], keyof import("long")>, never>);
        } & Record<Exclude<keyof I_10, keyof _18.RequestEndBlock>, never>>(object: I_10): _18.RequestEndBlock;
    };
    RequestCommit: {
        encode(message: _18.RequestCommit, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.RequestCommit;
        fromJSON(object: any): _18.RequestCommit;
        toJSON(message: _18.RequestCommit): unknown;
        fromPartial<I_11 extends {
            RequestBase?: {};
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_11["RequestBase"], never>, never>;
        } & Record<Exclude<keyof I_11, "RequestBase">, never>>(object: I_11): _18.RequestCommit;
    };
    ResponseBase: {
        encode(message: _18.ResponseBase, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.ResponseBase;
        fromJSON(object: any): _18.ResponseBase;
        toJSON(message: _18.ResponseBase): unknown;
        fromPartial<I_12 extends {
            Error?: {
                typeUrl?: string;
                value?: Uint8Array;
            };
            Data?: Uint8Array;
            Events?: {
                typeUrl?: string;
                value?: Uint8Array;
            }[];
            Log?: string;
            Info?: string;
        } & {
            Error?: {
                typeUrl?: string;
                value?: Uint8Array;
            } & {
                typeUrl?: string;
                value?: Uint8Array;
            } & Record<Exclude<keyof I_12["Error"], keyof import("../google/protobuf/any").Any>, never>;
            Data?: Uint8Array;
            Events?: {
                typeUrl?: string;
                value?: Uint8Array;
            }[] & ({
                typeUrl?: string;
                value?: Uint8Array;
            } & {
                typeUrl?: string;
                value?: Uint8Array;
            } & Record<Exclude<keyof I_12["Events"][number], keyof import("../google/protobuf/any").Any>, never>)[] & Record<Exclude<keyof I_12["Events"], keyof {
                typeUrl?: string;
                value?: Uint8Array;
            }[]>, never>;
            Log?: string;
            Info?: string;
        } & Record<Exclude<keyof I_12, keyof _18.ResponseBase>, never>>(object: I_12): _18.ResponseBase;
    };
    ResponseException: {
        encode(message: _18.ResponseException, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.ResponseException;
        fromJSON(object: any): _18.ResponseException;
        toJSON(message: _18.ResponseException): unknown;
        fromPartial<I_13 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_13["ResponseBase"]["Error"], keyof import("../google/protobuf/any").Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_13["ResponseBase"]["Events"][number], keyof import("../google/protobuf/any").Any>, never>)[] & Record<Exclude<keyof I_13["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_13["ResponseBase"], keyof _18.ResponseBase>, never>;
        } & Record<Exclude<keyof I_13, "ResponseBase">, never>>(object: I_13): _18.ResponseException;
    };
    ResponseEcho: {
        encode(message: _18.ResponseEcho, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.ResponseEcho;
        fromJSON(object: any): _18.ResponseEcho;
        toJSON(message: _18.ResponseEcho): unknown;
        fromPartial<I_14 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
            Message?: string;
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_14["ResponseBase"]["Error"], keyof import("../google/protobuf/any").Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_14["ResponseBase"]["Events"][number], keyof import("../google/protobuf/any").Any>, never>)[] & Record<Exclude<keyof I_14["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_14["ResponseBase"], keyof _18.ResponseBase>, never>;
            Message?: string;
        } & Record<Exclude<keyof I_14, keyof _18.ResponseEcho>, never>>(object: I_14): _18.ResponseEcho;
    };
    ResponseFlush: {
        encode(message: _18.ResponseFlush, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.ResponseFlush;
        fromJSON(object: any): _18.ResponseFlush;
        toJSON(message: _18.ResponseFlush): unknown;
        fromPartial<I_15 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_15["ResponseBase"]["Error"], keyof import("../google/protobuf/any").Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_15["ResponseBase"]["Events"][number], keyof import("../google/protobuf/any").Any>, never>)[] & Record<Exclude<keyof I_15["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_15["ResponseBase"], keyof _18.ResponseBase>, never>;
        } & Record<Exclude<keyof I_15, "ResponseBase">, never>>(object: I_15): _18.ResponseFlush;
    };
    ResponseInfo: {
        encode(message: _18.ResponseInfo, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.ResponseInfo;
        fromJSON(object: any): _18.ResponseInfo;
        toJSON(message: _18.ResponseInfo): unknown;
        fromPartial<I_16 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
            ABCIVersion?: string;
            AppVersion?: string;
            LastBlockHeight?: string | number | import("long");
            LastBlockAppHash?: Uint8Array;
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_16["ResponseBase"]["Error"], keyof import("../google/protobuf/any").Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_16["ResponseBase"]["Events"][number], keyof import("../google/protobuf/any").Any>, never>)[] & Record<Exclude<keyof I_16["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_16["ResponseBase"], keyof _18.ResponseBase>, never>;
            ABCIVersion?: string;
            AppVersion?: string;
            LastBlockHeight?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_16["LastBlockHeight"], keyof import("long")>, never>);
            LastBlockAppHash?: Uint8Array;
        } & Record<Exclude<keyof I_16, keyof _18.ResponseInfo>, never>>(object: I_16): _18.ResponseInfo;
    };
    ResponseSetOption: {
        encode(message: _18.ResponseSetOption, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.ResponseSetOption;
        fromJSON(object: any): _18.ResponseSetOption;
        toJSON(message: _18.ResponseSetOption): unknown;
        fromPartial<I_17 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_17["ResponseBase"]["Error"], keyof import("../google/protobuf/any").Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_17["ResponseBase"]["Events"][number], keyof import("../google/protobuf/any").Any>, never>)[] & Record<Exclude<keyof I_17["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_17["ResponseBase"], keyof _18.ResponseBase>, never>;
        } & Record<Exclude<keyof I_17, "ResponseBase">, never>>(object: I_17): _18.ResponseSetOption;
    };
    ResponseInitChain: {
        encode(message: _18.ResponseInitChain, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.ResponseInitChain;
        fromJSON(object: any): _18.ResponseInitChain;
        toJSON(message: _18.ResponseInitChain): unknown;
        fromPartial<I_18 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
            ConsensusParams?: {
                Block?: {
                    MaxTxBytes?: string | number | import("long");
                    MaxDataBytes?: string | number | import("long");
                    MaxBlockBytes?: string | number | import("long");
                    MaxGas?: string | number | import("long");
                    TimeIotaMS?: string | number | import("long");
                };
                Validator?: {
                    PubKeyTypeURLs?: string[];
                };
            };
            Validators?: {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            }[];
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_18["ResponseBase"]["Error"], keyof import("../google/protobuf/any").Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_18["ResponseBase"]["Events"][number], keyof import("../google/protobuf/any").Any>, never>)[] & Record<Exclude<keyof I_18["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_18["ResponseBase"], keyof _18.ResponseBase>, never>;
            ConsensusParams?: {
                Block?: {
                    MaxTxBytes?: string | number | import("long");
                    MaxDataBytes?: string | number | import("long");
                    MaxBlockBytes?: string | number | import("long");
                    MaxGas?: string | number | import("long");
                    TimeIotaMS?: string | number | import("long");
                };
                Validator?: {
                    PubKeyTypeURLs?: string[];
                };
            } & {
                Block?: {
                    MaxTxBytes?: string | number | import("long");
                    MaxDataBytes?: string | number | import("long");
                    MaxBlockBytes?: string | number | import("long");
                    MaxGas?: string | number | import("long");
                    TimeIotaMS?: string | number | import("long");
                } & {
                    MaxTxBytes?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_18["ConsensusParams"]["Block"]["MaxTxBytes"], keyof import("long")>, never>);
                    MaxDataBytes?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_18["ConsensusParams"]["Block"]["MaxDataBytes"], keyof import("long")>, never>);
                    MaxBlockBytes?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_18["ConsensusParams"]["Block"]["MaxBlockBytes"], keyof import("long")>, never>);
                    MaxGas?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_18["ConsensusParams"]["Block"]["MaxGas"], keyof import("long")>, never>);
                    TimeIotaMS?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_18["ConsensusParams"]["Block"]["TimeIotaMS"], keyof import("long")>, never>);
                } & Record<Exclude<keyof I_18["ConsensusParams"]["Block"], keyof _18.BlockParams>, never>;
                Validator?: {
                    PubKeyTypeURLs?: string[];
                } & {
                    PubKeyTypeURLs?: string[] & string[] & Record<Exclude<keyof I_18["ConsensusParams"]["Validator"]["PubKeyTypeURLs"], keyof string[]>, never>;
                } & Record<Exclude<keyof I_18["ConsensusParams"]["Validator"], "PubKeyTypeURLs">, never>;
            } & Record<Exclude<keyof I_18["ConsensusParams"], keyof _18.ConsensusParams>, never>;
            Validators?: {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            }[] & ({
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            } & {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_18["Validators"][number]["PubKey"], keyof import("../google/protobuf/any").Any>, never>;
                Power?: string | number | (import("long") & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long")) => import("long");
                    and: (other: string | number | import("long")) => import("long");
                    compare: (other: string | number | import("long")) => number;
                    comp: (other: string | number | import("long")) => number;
                    divide: (divisor: string | number | import("long")) => import("long");
                    div: (divisor: string | number | import("long")) => import("long");
                    equals: (other: string | number | import("long")) => boolean;
                    eq: (other: string | number | import("long")) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long")) => boolean;
                    gt: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                    gte: (other: string | number | import("long")) => boolean;
                    ge: (other: string | number | import("long")) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    eqz: () => boolean;
                    lessThan: (other: string | number | import("long")) => boolean;
                    lt: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual: (other: string | number | import("long")) => boolean;
                    lte: (other: string | number | import("long")) => boolean;
                    le: (other: string | number | import("long")) => boolean;
                    modulo: (other: string | number | import("long")) => import("long");
                    mod: (other: string | number | import("long")) => import("long");
                    rem: (other: string | number | import("long")) => import("long");
                    multiply: (multiplier: string | number | import("long")) => import("long");
                    mul: (multiplier: string | number | import("long")) => import("long");
                    negate: () => import("long");
                    neg: () => import("long");
                    not: () => import("long");
                    countLeadingZeros: () => number;
                    clz: () => number;
                    countTrailingZeros: () => number;
                    ctz: () => number;
                    notEquals: (other: string | number | import("long")) => boolean;
                    neq: (other: string | number | import("long")) => boolean;
                    ne: (other: string | number | import("long")) => boolean;
                    or: (other: string | number | import("long")) => import("long");
                    shiftLeft: (numBits: number | import("long")) => import("long");
                    shl: (numBits: number | import("long")) => import("long");
                    shiftRight: (numBits: number | import("long")) => import("long");
                    shr: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                    shru: (numBits: number | import("long")) => import("long");
                    shr_u: (numBits: number | import("long")) => import("long");
                    rotateLeft: (numBits: number | import("long")) => import("long");
                    rotl: (numBits: number | import("long")) => import("long");
                    rotateRight: (numBits: number | import("long")) => import("long");
                    rotr: (numBits: number | import("long")) => import("long");
                    subtract: (subtrahend: string | number | import("long")) => import("long");
                    sub: (subtrahend: string | number | import("long")) => import("long");
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long");
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long");
                    xor: (other: string | number | import("long")) => import("long");
                } & Record<Exclude<keyof I_18["Validators"][number]["Power"], keyof import("long")>, never>);
            } & Record<Exclude<keyof I_18["Validators"][number], keyof _18.ValidatorUpdate>, never>)[] & Record<Exclude<keyof I_18["Validators"], keyof {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            }[]>, never>;
        } & Record<Exclude<keyof I_18, keyof _18.ResponseInitChain>, never>>(object: I_18): _18.ResponseInitChain;
    };
    ResponseQuery: {
        encode(message: _18.ResponseQuery, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.ResponseQuery;
        fromJSON(object: any): _18.ResponseQuery;
        toJSON(message: _18.ResponseQuery): unknown;
        fromPartial<I_19 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
            Key?: Uint8Array;
            Value?: Uint8Array;
            Proof?: {
                Ops?: {
                    Type?: string;
                    Key?: Uint8Array;
                    Data?: Uint8Array;
                }[];
            };
            Height?: string | number | import("long");
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_19["ResponseBase"]["Error"], keyof import("../google/protobuf/any").Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_19["ResponseBase"]["Events"][number], keyof import("../google/protobuf/any").Any>, never>)[] & Record<Exclude<keyof I_19["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_19["ResponseBase"], keyof _18.ResponseBase>, never>;
            Key?: Uint8Array;
            Value?: Uint8Array;
            Proof?: {
                Ops?: {
                    Type?: string;
                    Key?: Uint8Array;
                    Data?: Uint8Array;
                }[];
            } & {
                Ops?: {
                    Type?: string;
                    Key?: Uint8Array;
                    Data?: Uint8Array;
                }[] & ({
                    Type?: string;
                    Key?: Uint8Array;
                    Data?: Uint8Array;
                } & {
                    Type?: string;
                    Key?: Uint8Array;
                    Data?: Uint8Array;
                } & Record<Exclude<keyof I_19["Proof"]["Ops"][number], keyof import("../github.com/gnolang/gno/pkgs/crypto/merkle/merkle").ProofOp>, never>)[] & Record<Exclude<keyof I_19["Proof"]["Ops"], keyof {
                    Type?: string;
                    Key?: Uint8Array;
                    Data?: Uint8Array;
                }[]>, never>;
            } & Record<Exclude<keyof I_19["Proof"], "Ops">, never>;
            Height?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_19["Height"], keyof import("long")>, never>);
        } & Record<Exclude<keyof I_19, keyof _18.ResponseQuery>, never>>(object: I_19): _18.ResponseQuery;
    };
    ResponseBeginBlock: {
        encode(message: _18.ResponseBeginBlock, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.ResponseBeginBlock;
        fromJSON(object: any): _18.ResponseBeginBlock;
        toJSON(message: _18.ResponseBeginBlock): unknown;
        fromPartial<I_20 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_20["ResponseBase"]["Error"], keyof import("../google/protobuf/any").Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_20["ResponseBase"]["Events"][number], keyof import("../google/protobuf/any").Any>, never>)[] & Record<Exclude<keyof I_20["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_20["ResponseBase"], keyof _18.ResponseBase>, never>;
        } & Record<Exclude<keyof I_20, "ResponseBase">, never>>(object: I_20): _18.ResponseBeginBlock;
    };
    ResponseCheckTx: {
        encode(message: _18.ResponseCheckTx, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.ResponseCheckTx;
        fromJSON(object: any): _18.ResponseCheckTx;
        toJSON(message: _18.ResponseCheckTx): unknown;
        fromPartial<I_21 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
            GasWanted?: string | number | import("long");
            GasUsed?: string | number | import("long");
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_21["ResponseBase"]["Error"], keyof import("../google/protobuf/any").Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_21["ResponseBase"]["Events"][number], keyof import("../google/protobuf/any").Any>, never>)[] & Record<Exclude<keyof I_21["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_21["ResponseBase"], keyof _18.ResponseBase>, never>;
            GasWanted?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_21["GasWanted"], keyof import("long")>, never>);
            GasUsed?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_21["GasUsed"], keyof import("long")>, never>);
        } & Record<Exclude<keyof I_21, keyof _18.ResponseCheckTx>, never>>(object: I_21): _18.ResponseCheckTx;
    };
    ResponseDeliverTx: {
        encode(message: _18.ResponseDeliverTx, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.ResponseDeliverTx;
        fromJSON(object: any): _18.ResponseDeliverTx;
        toJSON(message: _18.ResponseDeliverTx): unknown;
        fromPartial<I_22 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
            GasWanted?: string | number | import("long");
            GasUsed?: string | number | import("long");
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_22["ResponseBase"]["Error"], keyof import("../google/protobuf/any").Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_22["ResponseBase"]["Events"][number], keyof import("../google/protobuf/any").Any>, never>)[] & Record<Exclude<keyof I_22["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_22["ResponseBase"], keyof _18.ResponseBase>, never>;
            GasWanted?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_22["GasWanted"], keyof import("long")>, never>);
            GasUsed?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_22["GasUsed"], keyof import("long")>, never>);
        } & Record<Exclude<keyof I_22, keyof _18.ResponseDeliverTx>, never>>(object: I_22): _18.ResponseDeliverTx;
    };
    ResponseEndBlock: {
        encode(message: _18.ResponseEndBlock, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.ResponseEndBlock;
        fromJSON(object: any): _18.ResponseEndBlock;
        toJSON(message: _18.ResponseEndBlock): unknown;
        fromPartial<I_23 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
            ValidatorUpdates?: {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            }[];
            ConsensusParams?: {
                Block?: {
                    MaxTxBytes?: string | number | import("long");
                    MaxDataBytes?: string | number | import("long");
                    MaxBlockBytes?: string | number | import("long");
                    MaxGas?: string | number | import("long");
                    TimeIotaMS?: string | number | import("long");
                };
                Validator?: {
                    PubKeyTypeURLs?: string[];
                };
            };
            Events?: {
                typeUrl?: string;
                value?: Uint8Array;
            }[];
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_23["ResponseBase"]["Error"], keyof import("../google/protobuf/any").Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_23["ResponseBase"]["Events"][number], keyof import("../google/protobuf/any").Any>, never>)[] & Record<Exclude<keyof I_23["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_23["ResponseBase"], keyof _18.ResponseBase>, never>;
            ValidatorUpdates?: {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            }[] & ({
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            } & {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_23["ValidatorUpdates"][number]["PubKey"], keyof import("../google/protobuf/any").Any>, never>;
                Power?: string | number | (import("long") & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long")) => import("long");
                    and: (other: string | number | import("long")) => import("long");
                    compare: (other: string | number | import("long")) => number;
                    comp: (other: string | number | import("long")) => number;
                    divide: (divisor: string | number | import("long")) => import("long");
                    div: (divisor: string | number | import("long")) => import("long");
                    equals: (other: string | number | import("long")) => boolean;
                    eq: (other: string | number | import("long")) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long")) => boolean;
                    gt: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                    gte: (other: string | number | import("long")) => boolean;
                    ge: (other: string | number | import("long")) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    eqz: () => boolean;
                    lessThan: (other: string | number | import("long")) => boolean;
                    lt: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual: (other: string | number | import("long")) => boolean;
                    lte: (other: string | number | import("long")) => boolean;
                    le: (other: string | number | import("long")) => boolean;
                    modulo: (other: string | number | import("long")) => import("long");
                    mod: (other: string | number | import("long")) => import("long");
                    rem: (other: string | number | import("long")) => import("long");
                    multiply: (multiplier: string | number | import("long")) => import("long");
                    mul: (multiplier: string | number | import("long")) => import("long");
                    negate: () => import("long");
                    neg: () => import("long");
                    not: () => import("long");
                    countLeadingZeros: () => number;
                    clz: () => number;
                    countTrailingZeros: () => number;
                    ctz: () => number;
                    notEquals: (other: string | number | import("long")) => boolean;
                    neq: (other: string | number | import("long")) => boolean;
                    ne: (other: string | number | import("long")) => boolean;
                    or: (other: string | number | import("long")) => import("long");
                    shiftLeft: (numBits: number | import("long")) => import("long");
                    shl: (numBits: number | import("long")) => import("long");
                    shiftRight: (numBits: number | import("long")) => import("long");
                    shr: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                    shru: (numBits: number | import("long")) => import("long");
                    shr_u: (numBits: number | import("long")) => import("long");
                    rotateLeft: (numBits: number | import("long")) => import("long");
                    rotl: (numBits: number | import("long")) => import("long");
                    rotateRight: (numBits: number | import("long")) => import("long");
                    rotr: (numBits: number | import("long")) => import("long");
                    subtract: (subtrahend: string | number | import("long")) => import("long");
                    sub: (subtrahend: string | number | import("long")) => import("long");
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long");
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long");
                    xor: (other: string | number | import("long")) => import("long");
                } & Record<Exclude<keyof I_23["ValidatorUpdates"][number]["Power"], keyof import("long")>, never>);
            } & Record<Exclude<keyof I_23["ValidatorUpdates"][number], keyof _18.ValidatorUpdate>, never>)[] & Record<Exclude<keyof I_23["ValidatorUpdates"], keyof {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            }[]>, never>;
            ConsensusParams?: {
                Block?: {
                    MaxTxBytes?: string | number | import("long");
                    MaxDataBytes?: string | number | import("long");
                    MaxBlockBytes?: string | number | import("long");
                    MaxGas?: string | number | import("long");
                    TimeIotaMS?: string | number | import("long");
                };
                Validator?: {
                    PubKeyTypeURLs?: string[];
                };
            } & {
                Block?: {
                    MaxTxBytes?: string | number | import("long");
                    MaxDataBytes?: string | number | import("long");
                    MaxBlockBytes?: string | number | import("long");
                    MaxGas?: string | number | import("long");
                    TimeIotaMS?: string | number | import("long");
                } & {
                    MaxTxBytes?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_23["ConsensusParams"]["Block"]["MaxTxBytes"], keyof import("long")>, never>);
                    MaxDataBytes?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_23["ConsensusParams"]["Block"]["MaxDataBytes"], keyof import("long")>, never>);
                    MaxBlockBytes?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_23["ConsensusParams"]["Block"]["MaxBlockBytes"], keyof import("long")>, never>);
                    MaxGas?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_23["ConsensusParams"]["Block"]["MaxGas"], keyof import("long")>, never>);
                    TimeIotaMS?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_23["ConsensusParams"]["Block"]["TimeIotaMS"], keyof import("long")>, never>);
                } & Record<Exclude<keyof I_23["ConsensusParams"]["Block"], keyof _18.BlockParams>, never>;
                Validator?: {
                    PubKeyTypeURLs?: string[];
                } & {
                    PubKeyTypeURLs?: string[] & string[] & Record<Exclude<keyof I_23["ConsensusParams"]["Validator"]["PubKeyTypeURLs"], keyof string[]>, never>;
                } & Record<Exclude<keyof I_23["ConsensusParams"]["Validator"], "PubKeyTypeURLs">, never>;
            } & Record<Exclude<keyof I_23["ConsensusParams"], keyof _18.ConsensusParams>, never>;
            Events?: {
                typeUrl?: string;
                value?: Uint8Array;
            }[] & ({
                typeUrl?: string;
                value?: Uint8Array;
            } & {
                typeUrl?: string;
                value?: Uint8Array;
            } & Record<Exclude<keyof I_23["Events"][number], keyof import("../google/protobuf/any").Any>, never>)[] & Record<Exclude<keyof I_23["Events"], keyof {
                typeUrl?: string;
                value?: Uint8Array;
            }[]>, never>;
        } & Record<Exclude<keyof I_23, keyof _18.ResponseEndBlock>, never>>(object: I_23): _18.ResponseEndBlock;
    };
    ResponseCommit: {
        encode(message: _18.ResponseCommit, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.ResponseCommit;
        fromJSON(object: any): _18.ResponseCommit;
        toJSON(message: _18.ResponseCommit): unknown;
        fromPartial<I_24 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_24["ResponseBase"]["Error"], keyof import("../google/protobuf/any").Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_24["ResponseBase"]["Events"][number], keyof import("../google/protobuf/any").Any>, never>)[] & Record<Exclude<keyof I_24["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_24["ResponseBase"], keyof _18.ResponseBase>, never>;
        } & Record<Exclude<keyof I_24, "ResponseBase">, never>>(object: I_24): _18.ResponseCommit;
    };
    StringError: {
        encode(message: _18.StringError, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.StringError;
        fromJSON(object: any): _18.StringError;
        toJSON(message: _18.StringError): unknown;
        fromPartial<I_25 extends {
            Value?: string;
        } & {
            Value?: string;
        } & Record<Exclude<keyof I_25, "Value">, never>>(object: I_25): _18.StringError;
    };
    ConsensusParams: {
        encode(message: _18.ConsensusParams, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.ConsensusParams;
        fromJSON(object: any): _18.ConsensusParams;
        toJSON(message: _18.ConsensusParams): unknown;
        fromPartial<I_26 extends {
            Block?: {
                MaxTxBytes?: string | number | import("long");
                MaxDataBytes?: string | number | import("long");
                MaxBlockBytes?: string | number | import("long");
                MaxGas?: string | number | import("long");
                TimeIotaMS?: string | number | import("long");
            };
            Validator?: {
                PubKeyTypeURLs?: string[];
            };
        } & {
            Block?: {
                MaxTxBytes?: string | number | import("long");
                MaxDataBytes?: string | number | import("long");
                MaxBlockBytes?: string | number | import("long");
                MaxGas?: string | number | import("long");
                TimeIotaMS?: string | number | import("long");
            } & {
                MaxTxBytes?: string | number | (import("long") & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long")) => import("long");
                    and: (other: string | number | import("long")) => import("long");
                    compare: (other: string | number | import("long")) => number;
                    comp: (other: string | number | import("long")) => number;
                    divide: (divisor: string | number | import("long")) => import("long");
                    div: (divisor: string | number | import("long")) => import("long");
                    equals: (other: string | number | import("long")) => boolean;
                    eq: (other: string | number | import("long")) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long")) => boolean;
                    gt: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                    gte: (other: string | number | import("long")) => boolean;
                    ge: (other: string | number | import("long")) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    eqz: () => boolean;
                    lessThan: (other: string | number | import("long")) => boolean;
                    lt: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual: (other: string | number | import("long")) => boolean;
                    lte: (other: string | number | import("long")) => boolean;
                    le: (other: string | number | import("long")) => boolean;
                    modulo: (other: string | number | import("long")) => import("long");
                    mod: (other: string | number | import("long")) => import("long");
                    rem: (other: string | number | import("long")) => import("long");
                    multiply: (multiplier: string | number | import("long")) => import("long");
                    mul: (multiplier: string | number | import("long")) => import("long");
                    negate: () => import("long");
                    neg: () => import("long");
                    not: () => import("long");
                    countLeadingZeros: () => number;
                    clz: () => number;
                    countTrailingZeros: () => number;
                    ctz: () => number;
                    notEquals: (other: string | number | import("long")) => boolean;
                    neq: (other: string | number | import("long")) => boolean;
                    ne: (other: string | number | import("long")) => boolean;
                    or: (other: string | number | import("long")) => import("long");
                    shiftLeft: (numBits: number | import("long")) => import("long");
                    shl: (numBits: number | import("long")) => import("long");
                    shiftRight: (numBits: number | import("long")) => import("long");
                    shr: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                    shru: (numBits: number | import("long")) => import("long");
                    shr_u: (numBits: number | import("long")) => import("long");
                    rotateLeft: (numBits: number | import("long")) => import("long");
                    rotl: (numBits: number | import("long")) => import("long");
                    rotateRight: (numBits: number | import("long")) => import("long");
                    rotr: (numBits: number | import("long")) => import("long");
                    subtract: (subtrahend: string | number | import("long")) => import("long");
                    sub: (subtrahend: string | number | import("long")) => import("long");
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long");
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long");
                    xor: (other: string | number | import("long")) => import("long");
                } & Record<Exclude<keyof I_26["Block"]["MaxTxBytes"], keyof import("long")>, never>);
                MaxDataBytes?: string | number | (import("long") & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long")) => import("long");
                    and: (other: string | number | import("long")) => import("long");
                    compare: (other: string | number | import("long")) => number;
                    comp: (other: string | number | import("long")) => number;
                    divide: (divisor: string | number | import("long")) => import("long");
                    div: (divisor: string | number | import("long")) => import("long");
                    equals: (other: string | number | import("long")) => boolean;
                    eq: (other: string | number | import("long")) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long")) => boolean;
                    gt: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                    gte: (other: string | number | import("long")) => boolean;
                    ge: (other: string | number | import("long")) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    eqz: () => boolean;
                    lessThan: (other: string | number | import("long")) => boolean;
                    lt: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual: (other: string | number | import("long")) => boolean;
                    lte: (other: string | number | import("long")) => boolean;
                    le: (other: string | number | import("long")) => boolean;
                    modulo: (other: string | number | import("long")) => import("long");
                    mod: (other: string | number | import("long")) => import("long");
                    rem: (other: string | number | import("long")) => import("long");
                    multiply: (multiplier: string | number | import("long")) => import("long");
                    mul: (multiplier: string | number | import("long")) => import("long");
                    negate: () => import("long");
                    neg: () => import("long");
                    not: () => import("long");
                    countLeadingZeros: () => number;
                    clz: () => number;
                    countTrailingZeros: () => number;
                    ctz: () => number;
                    notEquals: (other: string | number | import("long")) => boolean;
                    neq: (other: string | number | import("long")) => boolean;
                    ne: (other: string | number | import("long")) => boolean;
                    or: (other: string | number | import("long")) => import("long");
                    shiftLeft: (numBits: number | import("long")) => import("long");
                    shl: (numBits: number | import("long")) => import("long");
                    shiftRight: (numBits: number | import("long")) => import("long");
                    shr: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                    shru: (numBits: number | import("long")) => import("long");
                    shr_u: (numBits: number | import("long")) => import("long");
                    rotateLeft: (numBits: number | import("long")) => import("long");
                    rotl: (numBits: number | import("long")) => import("long");
                    rotateRight: (numBits: number | import("long")) => import("long");
                    rotr: (numBits: number | import("long")) => import("long");
                    subtract: (subtrahend: string | number | import("long")) => import("long");
                    sub: (subtrahend: string | number | import("long")) => import("long");
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long");
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long");
                    xor: (other: string | number | import("long")) => import("long");
                } & Record<Exclude<keyof I_26["Block"]["MaxDataBytes"], keyof import("long")>, never>);
                MaxBlockBytes?: string | number | (import("long") & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long")) => import("long");
                    and: (other: string | number | import("long")) => import("long");
                    compare: (other: string | number | import("long")) => number;
                    comp: (other: string | number | import("long")) => number;
                    divide: (divisor: string | number | import("long")) => import("long");
                    div: (divisor: string | number | import("long")) => import("long");
                    equals: (other: string | number | import("long")) => boolean;
                    eq: (other: string | number | import("long")) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long")) => boolean;
                    gt: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                    gte: (other: string | number | import("long")) => boolean;
                    ge: (other: string | number | import("long")) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    eqz: () => boolean;
                    lessThan: (other: string | number | import("long")) => boolean;
                    lt: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual: (other: string | number | import("long")) => boolean;
                    lte: (other: string | number | import("long")) => boolean;
                    le: (other: string | number | import("long")) => boolean;
                    modulo: (other: string | number | import("long")) => import("long");
                    mod: (other: string | number | import("long")) => import("long");
                    rem: (other: string | number | import("long")) => import("long");
                    multiply: (multiplier: string | number | import("long")) => import("long");
                    mul: (multiplier: string | number | import("long")) => import("long");
                    negate: () => import("long");
                    neg: () => import("long");
                    not: () => import("long");
                    countLeadingZeros: () => number;
                    clz: () => number;
                    countTrailingZeros: () => number;
                    ctz: () => number;
                    notEquals: (other: string | number | import("long")) => boolean;
                    neq: (other: string | number | import("long")) => boolean;
                    ne: (other: string | number | import("long")) => boolean;
                    or: (other: string | number | import("long")) => import("long");
                    shiftLeft: (numBits: number | import("long")) => import("long");
                    shl: (numBits: number | import("long")) => import("long");
                    shiftRight: (numBits: number | import("long")) => import("long");
                    shr: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                    shru: (numBits: number | import("long")) => import("long");
                    shr_u: (numBits: number | import("long")) => import("long");
                    rotateLeft: (numBits: number | import("long")) => import("long");
                    rotl: (numBits: number | import("long")) => import("long");
                    rotateRight: (numBits: number | import("long")) => import("long");
                    rotr: (numBits: number | import("long")) => import("long");
                    subtract: (subtrahend: string | number | import("long")) => import("long");
                    sub: (subtrahend: string | number | import("long")) => import("long");
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long");
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long");
                    xor: (other: string | number | import("long")) => import("long");
                } & Record<Exclude<keyof I_26["Block"]["MaxBlockBytes"], keyof import("long")>, never>);
                MaxGas?: string | number | (import("long") & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long")) => import("long");
                    and: (other: string | number | import("long")) => import("long");
                    compare: (other: string | number | import("long")) => number;
                    comp: (other: string | number | import("long")) => number;
                    divide: (divisor: string | number | import("long")) => import("long");
                    div: (divisor: string | number | import("long")) => import("long");
                    equals: (other: string | number | import("long")) => boolean;
                    eq: (other: string | number | import("long")) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long")) => boolean;
                    gt: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                    gte: (other: string | number | import("long")) => boolean;
                    ge: (other: string | number | import("long")) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    eqz: () => boolean;
                    lessThan: (other: string | number | import("long")) => boolean;
                    lt: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual: (other: string | number | import("long")) => boolean;
                    lte: (other: string | number | import("long")) => boolean;
                    le: (other: string | number | import("long")) => boolean;
                    modulo: (other: string | number | import("long")) => import("long");
                    mod: (other: string | number | import("long")) => import("long");
                    rem: (other: string | number | import("long")) => import("long");
                    multiply: (multiplier: string | number | import("long")) => import("long");
                    mul: (multiplier: string | number | import("long")) => import("long");
                    negate: () => import("long");
                    neg: () => import("long");
                    not: () => import("long");
                    countLeadingZeros: () => number;
                    clz: () => number;
                    countTrailingZeros: () => number;
                    ctz: () => number;
                    notEquals: (other: string | number | import("long")) => boolean;
                    neq: (other: string | number | import("long")) => boolean;
                    ne: (other: string | number | import("long")) => boolean;
                    or: (other: string | number | import("long")) => import("long");
                    shiftLeft: (numBits: number | import("long")) => import("long");
                    shl: (numBits: number | import("long")) => import("long");
                    shiftRight: (numBits: number | import("long")) => import("long");
                    shr: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                    shru: (numBits: number | import("long")) => import("long");
                    shr_u: (numBits: number | import("long")) => import("long");
                    rotateLeft: (numBits: number | import("long")) => import("long");
                    rotl: (numBits: number | import("long")) => import("long");
                    rotateRight: (numBits: number | import("long")) => import("long");
                    rotr: (numBits: number | import("long")) => import("long");
                    subtract: (subtrahend: string | number | import("long")) => import("long");
                    sub: (subtrahend: string | number | import("long")) => import("long");
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long");
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long");
                    xor: (other: string | number | import("long")) => import("long");
                } & Record<Exclude<keyof I_26["Block"]["MaxGas"], keyof import("long")>, never>);
                TimeIotaMS?: string | number | (import("long") & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long")) => import("long");
                    and: (other: string | number | import("long")) => import("long");
                    compare: (other: string | number | import("long")) => number;
                    comp: (other: string | number | import("long")) => number;
                    divide: (divisor: string | number | import("long")) => import("long");
                    div: (divisor: string | number | import("long")) => import("long");
                    equals: (other: string | number | import("long")) => boolean;
                    eq: (other: string | number | import("long")) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long")) => boolean;
                    gt: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                    gte: (other: string | number | import("long")) => boolean;
                    ge: (other: string | number | import("long")) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    eqz: () => boolean;
                    lessThan: (other: string | number | import("long")) => boolean;
                    lt: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual: (other: string | number | import("long")) => boolean;
                    lte: (other: string | number | import("long")) => boolean;
                    le: (other: string | number | import("long")) => boolean;
                    modulo: (other: string | number | import("long")) => import("long");
                    mod: (other: string | number | import("long")) => import("long");
                    rem: (other: string | number | import("long")) => import("long");
                    multiply: (multiplier: string | number | import("long")) => import("long");
                    mul: (multiplier: string | number | import("long")) => import("long");
                    negate: () => import("long");
                    neg: () => import("long");
                    not: () => import("long");
                    countLeadingZeros: () => number;
                    clz: () => number;
                    countTrailingZeros: () => number;
                    ctz: () => number;
                    notEquals: (other: string | number | import("long")) => boolean;
                    neq: (other: string | number | import("long")) => boolean;
                    ne: (other: string | number | import("long")) => boolean;
                    or: (other: string | number | import("long")) => import("long");
                    shiftLeft: (numBits: number | import("long")) => import("long");
                    shl: (numBits: number | import("long")) => import("long");
                    shiftRight: (numBits: number | import("long")) => import("long");
                    shr: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                    shru: (numBits: number | import("long")) => import("long");
                    shr_u: (numBits: number | import("long")) => import("long");
                    rotateLeft: (numBits: number | import("long")) => import("long");
                    rotl: (numBits: number | import("long")) => import("long");
                    rotateRight: (numBits: number | import("long")) => import("long");
                    rotr: (numBits: number | import("long")) => import("long");
                    subtract: (subtrahend: string | number | import("long")) => import("long");
                    sub: (subtrahend: string | number | import("long")) => import("long");
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long");
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long");
                    xor: (other: string | number | import("long")) => import("long");
                } & Record<Exclude<keyof I_26["Block"]["TimeIotaMS"], keyof import("long")>, never>);
            } & Record<Exclude<keyof I_26["Block"], keyof _18.BlockParams>, never>;
            Validator?: {
                PubKeyTypeURLs?: string[];
            } & {
                PubKeyTypeURLs?: string[] & string[] & Record<Exclude<keyof I_26["Validator"]["PubKeyTypeURLs"], keyof string[]>, never>;
            } & Record<Exclude<keyof I_26["Validator"], "PubKeyTypeURLs">, never>;
        } & Record<Exclude<keyof I_26, keyof _18.ConsensusParams>, never>>(object: I_26): _18.ConsensusParams;
    };
    BlockParams: {
        encode(message: _18.BlockParams, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.BlockParams;
        fromJSON(object: any): _18.BlockParams;
        toJSON(message: _18.BlockParams): unknown;
        fromPartial<I_27 extends {
            MaxTxBytes?: string | number | import("long");
            MaxDataBytes?: string | number | import("long");
            MaxBlockBytes?: string | number | import("long");
            MaxGas?: string | number | import("long");
            TimeIotaMS?: string | number | import("long");
        } & {
            MaxTxBytes?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_27["MaxTxBytes"], keyof import("long")>, never>);
            MaxDataBytes?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_27["MaxDataBytes"], keyof import("long")>, never>);
            MaxBlockBytes?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_27["MaxBlockBytes"], keyof import("long")>, never>);
            MaxGas?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_27["MaxGas"], keyof import("long")>, never>);
            TimeIotaMS?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_27["TimeIotaMS"], keyof import("long")>, never>);
        } & Record<Exclude<keyof I_27, keyof _18.BlockParams>, never>>(object: I_27): _18.BlockParams;
    };
    ValidatorParams: {
        encode(message: _18.ValidatorParams, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.ValidatorParams;
        fromJSON(object: any): _18.ValidatorParams;
        toJSON(message: _18.ValidatorParams): unknown;
        fromPartial<I_28 extends {
            PubKeyTypeURLs?: string[];
        } & {
            PubKeyTypeURLs?: string[] & string[] & Record<Exclude<keyof I_28["PubKeyTypeURLs"], keyof string[]>, never>;
        } & Record<Exclude<keyof I_28, "PubKeyTypeURLs">, never>>(object: I_28): _18.ValidatorParams;
    };
    ValidatorUpdate: {
        encode(message: _18.ValidatorUpdate, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.ValidatorUpdate;
        fromJSON(object: any): _18.ValidatorUpdate;
        toJSON(message: _18.ValidatorUpdate): unknown;
        fromPartial<I_29 extends {
            Address?: string;
            PubKey?: {
                typeUrl?: string;
                value?: Uint8Array;
            };
            Power?: string | number | import("long");
        } & {
            Address?: string;
            PubKey?: {
                typeUrl?: string;
                value?: Uint8Array;
            } & {
                typeUrl?: string;
                value?: Uint8Array;
            } & Record<Exclude<keyof I_29["PubKey"], keyof import("../google/protobuf/any").Any>, never>;
            Power?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_29["Power"], keyof import("long")>, never>);
        } & Record<Exclude<keyof I_29, keyof _18.ValidatorUpdate>, never>>(object: I_29): _18.ValidatorUpdate;
    };
    LastCommitInfo: {
        encode(message: _18.LastCommitInfo, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.LastCommitInfo;
        fromJSON(object: any): _18.LastCommitInfo;
        toJSON(message: _18.LastCommitInfo): unknown;
        fromPartial<I_30 extends {
            Round?: number;
            Votes?: {
                Address?: string;
                Power?: string | number | import("long");
                SignedLastBlock?: boolean;
            }[];
        } & {
            Round?: number;
            Votes?: {
                Address?: string;
                Power?: string | number | import("long");
                SignedLastBlock?: boolean;
            }[] & ({
                Address?: string;
                Power?: string | number | import("long");
                SignedLastBlock?: boolean;
            } & {
                Address?: string;
                Power?: string | number | (import("long") & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long")) => import("long");
                    and: (other: string | number | import("long")) => import("long");
                    compare: (other: string | number | import("long")) => number;
                    comp: (other: string | number | import("long")) => number;
                    divide: (divisor: string | number | import("long")) => import("long");
                    div: (divisor: string | number | import("long")) => import("long");
                    equals: (other: string | number | import("long")) => boolean;
                    eq: (other: string | number | import("long")) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long")) => boolean;
                    gt: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                    gte: (other: string | number | import("long")) => boolean;
                    ge: (other: string | number | import("long")) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    eqz: () => boolean;
                    lessThan: (other: string | number | import("long")) => boolean;
                    lt: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual: (other: string | number | import("long")) => boolean;
                    lte: (other: string | number | import("long")) => boolean;
                    le: (other: string | number | import("long")) => boolean;
                    modulo: (other: string | number | import("long")) => import("long");
                    mod: (other: string | number | import("long")) => import("long");
                    rem: (other: string | number | import("long")) => import("long");
                    multiply: (multiplier: string | number | import("long")) => import("long");
                    mul: (multiplier: string | number | import("long")) => import("long");
                    negate: () => import("long");
                    neg: () => import("long");
                    not: () => import("long");
                    countLeadingZeros: () => number;
                    clz: () => number;
                    countTrailingZeros: () => number;
                    ctz: () => number;
                    notEquals: (other: string | number | import("long")) => boolean;
                    neq: (other: string | number | import("long")) => boolean;
                    ne: (other: string | number | import("long")) => boolean;
                    or: (other: string | number | import("long")) => import("long");
                    shiftLeft: (numBits: number | import("long")) => import("long");
                    shl: (numBits: number | import("long")) => import("long");
                    shiftRight: (numBits: number | import("long")) => import("long");
                    shr: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                    shru: (numBits: number | import("long")) => import("long");
                    shr_u: (numBits: number | import("long")) => import("long");
                    rotateLeft: (numBits: number | import("long")) => import("long");
                    rotl: (numBits: number | import("long")) => import("long");
                    rotateRight: (numBits: number | import("long")) => import("long");
                    rotr: (numBits: number | import("long")) => import("long");
                    subtract: (subtrahend: string | number | import("long")) => import("long");
                    sub: (subtrahend: string | number | import("long")) => import("long");
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long");
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long");
                    xor: (other: string | number | import("long")) => import("long");
                } & Record<Exclude<keyof I_30["Votes"][number]["Power"], keyof import("long")>, never>);
                SignedLastBlock?: boolean;
            } & Record<Exclude<keyof I_30["Votes"][number], keyof _18.VoteInfo>, never>)[] & Record<Exclude<keyof I_30["Votes"], keyof {
                Address?: string;
                Power?: string | number | import("long");
                SignedLastBlock?: boolean;
            }[]>, never>;
        } & Record<Exclude<keyof I_30, keyof _18.LastCommitInfo>, never>>(object: I_30): _18.LastCommitInfo;
    };
    VoteInfo: {
        encode(message: _18.VoteInfo, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.VoteInfo;
        fromJSON(object: any): _18.VoteInfo;
        toJSON(message: _18.VoteInfo): unknown;
        fromPartial<I_31 extends {
            Address?: string;
            Power?: string | number | import("long");
            SignedLastBlock?: boolean;
        } & {
            Address?: string;
            Power?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_31["Power"], keyof import("long")>, never>);
            SignedLastBlock?: boolean;
        } & Record<Exclude<keyof I_31, keyof _18.VoteInfo>, never>>(object: I_31): _18.VoteInfo;
    };
    EventString: {
        encode(message: _18.EventString, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.EventString;
        fromJSON(object: any): _18.EventString;
        toJSON(message: _18.EventString): unknown;
        fromPartial<I_32 extends {
            Value?: string;
        } & {
            Value?: string;
        } & Record<Exclude<keyof I_32, "Value">, never>>(object: I_32): _18.EventString;
    };
    MockHeader: {
        encode(message: _18.MockHeader, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _18.MockHeader;
        fromJSON(object: any): _18.MockHeader;
        toJSON(message: _18.MockHeader): unknown;
        fromPartial<I_33 extends {
            Version?: string;
            ChainID?: string;
            Height?: string | number | import("long");
            Time?: Date;
            NumTxs?: string | number | import("long");
            TotalTxs?: string | number | import("long");
        } & {
            Version?: string;
            ChainID?: string;
            Height?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_33["Height"], keyof import("long")>, never>);
            Time?: Date;
            NumTxs?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_33["NumTxs"], keyof import("long")>, never>);
            TotalTxs?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_33["TotalTxs"], keyof import("long")>, never>);
        } & Record<Exclude<keyof I_33, keyof _18.MockHeader>, never>>(object: I_33): _18.MockHeader;
    };
};
