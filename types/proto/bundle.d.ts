import * as _0 from "./github.com/gnolang/gno/pkgs/bft/abci/types/abci";
import * as _1 from "./github.com/gnolang/gno/pkgs/crypto/ed25519/ed25519";
import * as _2 from "./github.com/gnolang/gno/pkgs/crypto/merkle/merkle";
import * as _3 from "./github.com/gnolang/gno/pkgs/crypto/multisig/multisig";
import * as _4 from "./github.com/gnolang/gno/pkgs/crypto/secp256k1/secp256k1";
import * as _5 from "./google/protobuf/any";
import * as _6 from "./google/protobuf/timestamp";
export declare const abci: {
    RequestBase: {
        encode(_: _0.RequestBase, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.RequestBase;
        fromJSON(_: any): _0.RequestBase;
        toJSON(_: _0.RequestBase): unknown;
        fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): _0.RequestBase;
    };
    RequestEcho: {
        encode(message: _0.RequestEcho, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.RequestEcho;
        fromJSON(object: any): _0.RequestEcho;
        toJSON(message: _0.RequestEcho): unknown;
        fromPartial<I_1 extends {
            RequestBase?: {};
            Message?: string;
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_1["RequestBase"], never>, never>;
            Message?: string;
        } & Record<Exclude<keyof I_1, keyof _0.RequestEcho>, never>>(object: I_1): _0.RequestEcho;
    };
    RequestFlush: {
        encode(message: _0.RequestFlush, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.RequestFlush;
        fromJSON(object: any): _0.RequestFlush;
        toJSON(message: _0.RequestFlush): unknown;
        fromPartial<I_2 extends {
            RequestBase?: {};
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_2["RequestBase"], never>, never>;
        } & Record<Exclude<keyof I_2, "RequestBase">, never>>(object: I_2): _0.RequestFlush;
    };
    RequestInfo: {
        encode(message: _0.RequestInfo, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.RequestInfo;
        fromJSON(object: any): _0.RequestInfo;
        toJSON(message: _0.RequestInfo): unknown;
        fromPartial<I_3 extends {
            RequestBase?: {};
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_3["RequestBase"], never>, never>;
        } & Record<Exclude<keyof I_3, "RequestBase">, never>>(object: I_3): _0.RequestInfo;
    };
    RequestSetOption: {
        encode(message: _0.RequestSetOption, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.RequestSetOption;
        fromJSON(object: any): _0.RequestSetOption;
        toJSON(message: _0.RequestSetOption): unknown;
        fromPartial<I_4 extends {
            RequestBase?: {};
            Key?: string;
            Value?: string;
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_4["RequestBase"], never>, never>;
            Key?: string;
            Value?: string;
        } & Record<Exclude<keyof I_4, keyof _0.RequestSetOption>, never>>(object: I_4): _0.RequestSetOption;
    };
    RequestInitChain: {
        encode(message: _0.RequestInitChain, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.RequestInitChain;
        fromJSON(object: any): _0.RequestInitChain;
        toJSON(message: _0.RequestInitChain): unknown;
        fromPartial<I_5 extends {
            RequestBase?: {};
            Time?: Date;
            ChainID?: string;
            ConsensusParams?: {
                Block?: {
                    MaxTxBytes?: string | number | import("long");
                    MaxDataBytes?: string | number | import("long");
                    MaxBlockBytes?: string | number | import("long");
                    MaxGas?: string | number | import("long");
                    TimeIotaMS?: string | number | import("long");
                };
                Validator?: {
                    PubKeyTypeURLs?: string[];
                };
            };
            Validators?: {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            }[];
            AppState?: {
                typeUrl?: string;
                value?: Uint8Array;
            };
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_5["RequestBase"], never>, never>;
            Time?: Date;
            ChainID?: string;
            ConsensusParams?: {
                Block?: {
                    MaxTxBytes?: string | number | import("long");
                    MaxDataBytes?: string | number | import("long");
                    MaxBlockBytes?: string | number | import("long");
                    MaxGas?: string | number | import("long");
                    TimeIotaMS?: string | number | import("long");
                };
                Validator?: {
                    PubKeyTypeURLs?: string[];
                };
            } & {
                Block?: {
                    MaxTxBytes?: string | number | import("long");
                    MaxDataBytes?: string | number | import("long");
                    MaxBlockBytes?: string | number | import("long");
                    MaxGas?: string | number | import("long");
                    TimeIotaMS?: string | number | import("long");
                } & {
                    MaxTxBytes?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_5["ConsensusParams"]["Block"]["MaxTxBytes"], keyof import("long")>, never>);
                    MaxDataBytes?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_5["ConsensusParams"]["Block"]["MaxDataBytes"], keyof import("long")>, never>);
                    MaxBlockBytes?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_5["ConsensusParams"]["Block"]["MaxBlockBytes"], keyof import("long")>, never>);
                    MaxGas?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_5["ConsensusParams"]["Block"]["MaxGas"], keyof import("long")>, never>);
                    TimeIotaMS?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_5["ConsensusParams"]["Block"]["TimeIotaMS"], keyof import("long")>, never>);
                } & Record<Exclude<keyof I_5["ConsensusParams"]["Block"], keyof _0.BlockParams>, never>;
                Validator?: {
                    PubKeyTypeURLs?: string[];
                } & {
                    PubKeyTypeURLs?: string[] & string[] & Record<Exclude<keyof I_5["ConsensusParams"]["Validator"]["PubKeyTypeURLs"], keyof string[]>, never>;
                } & Record<Exclude<keyof I_5["ConsensusParams"]["Validator"], "PubKeyTypeURLs">, never>;
            } & Record<Exclude<keyof I_5["ConsensusParams"], keyof _0.ConsensusParams>, never>;
            Validators?: {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            }[] & ({
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            } & {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_5["Validators"][number]["PubKey"], keyof _5.Any>, never>;
                Power?: string | number | (import("long") & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long")) => import("long");
                    and: (other: string | number | import("long")) => import("long");
                    compare: (other: string | number | import("long")) => number;
                    comp: (other: string | number | import("long")) => number;
                    divide: (divisor: string | number | import("long")) => import("long");
                    div: (divisor: string | number | import("long")) => import("long");
                    equals: (other: string | number | import("long")) => boolean;
                    eq: (other: string | number | import("long")) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long")) => boolean;
                    gt: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                    gte: (other: string | number | import("long")) => boolean;
                    ge: (other: string | number | import("long")) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    eqz: () => boolean;
                    lessThan: (other: string | number | import("long")) => boolean;
                    lt: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual: (other: string | number | import("long")) => boolean;
                    lte: (other: string | number | import("long")) => boolean;
                    le: (other: string | number | import("long")) => boolean;
                    modulo: (other: string | number | import("long")) => import("long");
                    mod: (other: string | number | import("long")) => import("long");
                    rem: (other: string | number | import("long")) => import("long");
                    multiply: (multiplier: string | number | import("long")) => import("long");
                    mul: (multiplier: string | number | import("long")) => import("long");
                    negate: () => import("long");
                    neg: () => import("long");
                    not: () => import("long");
                    countLeadingZeros: () => number;
                    clz: () => number;
                    countTrailingZeros: () => number;
                    ctz: () => number;
                    notEquals: (other: string | number | import("long")) => boolean;
                    neq: (other: string | number | import("long")) => boolean;
                    ne: (other: string | number | import("long")) => boolean;
                    or: (other: string | number | import("long")) => import("long");
                    shiftLeft: (numBits: number | import("long")) => import("long");
                    shl: (numBits: number | import("long")) => import("long");
                    shiftRight: (numBits: number | import("long")) => import("long");
                    shr: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                    shru: (numBits: number | import("long")) => import("long");
                    shr_u: (numBits: number | import("long")) => import("long");
                    rotateLeft: (numBits: number | import("long")) => import("long");
                    rotl: (numBits: number | import("long")) => import("long");
                    rotateRight: (numBits: number | import("long")) => import("long");
                    rotr: (numBits: number | import("long")) => import("long");
                    subtract: (subtrahend: string | number | import("long")) => import("long");
                    sub: (subtrahend: string | number | import("long")) => import("long");
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long");
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long");
                    xor: (other: string | number | import("long")) => import("long");
                } & Record<Exclude<keyof I_5["Validators"][number]["Power"], keyof import("long")>, never>);
            } & Record<Exclude<keyof I_5["Validators"][number], keyof _0.ValidatorUpdate>, never>)[] & Record<Exclude<keyof I_5["Validators"], keyof {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            }[]>, never>;
            AppState?: {
                typeUrl?: string;
                value?: Uint8Array;
            } & {
                typeUrl?: string;
                value?: Uint8Array;
            } & Record<Exclude<keyof I_5["AppState"], keyof _5.Any>, never>;
        } & Record<Exclude<keyof I_5, keyof _0.RequestInitChain>, never>>(object: I_5): _0.RequestInitChain;
    };
    RequestQuery: {
        encode(message: _0.RequestQuery, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.RequestQuery;
        fromJSON(object: any): _0.RequestQuery;
        toJSON(message: _0.RequestQuery): unknown;
        fromPartial<I_6 extends {
            RequestBase?: {};
            Data?: Uint8Array;
            Path?: string;
            Height?: string | number | import("long");
            Prove?: boolean;
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_6["RequestBase"], never>, never>;
            Data?: Uint8Array;
            Path?: string;
            Height?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_6["Height"], keyof import("long")>, never>);
            Prove?: boolean;
        } & Record<Exclude<keyof I_6, keyof _0.RequestQuery>, never>>(object: I_6): _0.RequestQuery;
    };
    RequestBeginBlock: {
        encode(message: _0.RequestBeginBlock, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.RequestBeginBlock;
        fromJSON(object: any): _0.RequestBeginBlock;
        toJSON(message: _0.RequestBeginBlock): unknown;
        fromPartial<I_7 extends {
            RequestBase?: {};
            Hash?: Uint8Array;
            Header?: {
                typeUrl?: string;
                value?: Uint8Array;
            };
            LastCommitInfo?: {
                Round?: number;
                Votes?: {
                    Address?: string;
                    Power?: string | number | import("long");
                    SignedLastBlock?: boolean;
                }[];
            };
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_7["RequestBase"], never>, never>;
            Hash?: Uint8Array;
            Header?: {
                typeUrl?: string;
                value?: Uint8Array;
            } & {
                typeUrl?: string;
                value?: Uint8Array;
            } & Record<Exclude<keyof I_7["Header"], keyof _5.Any>, never>;
            LastCommitInfo?: {
                Round?: number;
                Votes?: {
                    Address?: string;
                    Power?: string | number | import("long");
                    SignedLastBlock?: boolean;
                }[];
            } & {
                Round?: number;
                Votes?: {
                    Address?: string;
                    Power?: string | number | import("long");
                    SignedLastBlock?: boolean;
                }[] & ({
                    Address?: string;
                    Power?: string | number | import("long");
                    SignedLastBlock?: boolean;
                } & {
                    Address?: string;
                    Power?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_7["LastCommitInfo"]["Votes"][number]["Power"], keyof import("long")>, never>);
                    SignedLastBlock?: boolean;
                } & Record<Exclude<keyof I_7["LastCommitInfo"]["Votes"][number], keyof _0.VoteInfo>, never>)[] & Record<Exclude<keyof I_7["LastCommitInfo"]["Votes"], keyof {
                    Address?: string;
                    Power?: string | number | import("long");
                    SignedLastBlock?: boolean;
                }[]>, never>;
            } & Record<Exclude<keyof I_7["LastCommitInfo"], keyof _0.LastCommitInfo>, never>;
        } & Record<Exclude<keyof I_7, keyof _0.RequestBeginBlock>, never>>(object: I_7): _0.RequestBeginBlock;
    };
    RequestCheckTx: {
        encode(message: _0.RequestCheckTx, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.RequestCheckTx;
        fromJSON(object: any): _0.RequestCheckTx;
        toJSON(message: _0.RequestCheckTx): unknown;
        fromPartial<I_8 extends {
            RequestBase?: {};
            Tx?: Uint8Array;
            Type?: string | number | import("long");
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_8["RequestBase"], never>, never>;
            Tx?: Uint8Array;
            Type?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_8["Type"], keyof import("long")>, never>);
        } & Record<Exclude<keyof I_8, keyof _0.RequestCheckTx>, never>>(object: I_8): _0.RequestCheckTx;
    };
    RequestDeliverTx: {
        encode(message: _0.RequestDeliverTx, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.RequestDeliverTx;
        fromJSON(object: any): _0.RequestDeliverTx;
        toJSON(message: _0.RequestDeliverTx): unknown;
        fromPartial<I_9 extends {
            RequestBase?: {};
            Tx?: Uint8Array;
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_9["RequestBase"], never>, never>;
            Tx?: Uint8Array;
        } & Record<Exclude<keyof I_9, keyof _0.RequestDeliverTx>, never>>(object: I_9): _0.RequestDeliverTx;
    };
    RequestEndBlock: {
        encode(message: _0.RequestEndBlock, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.RequestEndBlock;
        fromJSON(object: any): _0.RequestEndBlock;
        toJSON(message: _0.RequestEndBlock): unknown;
        fromPartial<I_10 extends {
            RequestBase?: {};
            Height?: string | number | import("long");
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_10["RequestBase"], never>, never>;
            Height?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_10["Height"], keyof import("long")>, never>);
        } & Record<Exclude<keyof I_10, keyof _0.RequestEndBlock>, never>>(object: I_10): _0.RequestEndBlock;
    };
    RequestCommit: {
        encode(message: _0.RequestCommit, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.RequestCommit;
        fromJSON(object: any): _0.RequestCommit;
        toJSON(message: _0.RequestCommit): unknown;
        fromPartial<I_11 extends {
            RequestBase?: {};
        } & {
            RequestBase?: {} & {} & Record<Exclude<keyof I_11["RequestBase"], never>, never>;
        } & Record<Exclude<keyof I_11, "RequestBase">, never>>(object: I_11): _0.RequestCommit;
    };
    ResponseBase: {
        encode(message: _0.ResponseBase, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.ResponseBase;
        fromJSON(object: any): _0.ResponseBase;
        toJSON(message: _0.ResponseBase): unknown;
        fromPartial<I_12 extends {
            Error?: {
                typeUrl?: string;
                value?: Uint8Array;
            };
            Data?: Uint8Array;
            Events?: {
                typeUrl?: string;
                value?: Uint8Array;
            }[];
            Log?: string;
            Info?: string;
        } & {
            Error?: {
                typeUrl?: string;
                value?: Uint8Array;
            } & {
                typeUrl?: string;
                value?: Uint8Array;
            } & Record<Exclude<keyof I_12["Error"], keyof _5.Any>, never>;
            Data?: Uint8Array;
            Events?: {
                typeUrl?: string;
                value?: Uint8Array;
            }[] & ({
                typeUrl?: string;
                value?: Uint8Array;
            } & {
                typeUrl?: string;
                value?: Uint8Array;
            } & Record<Exclude<keyof I_12["Events"][number], keyof _5.Any>, never>)[] & Record<Exclude<keyof I_12["Events"], keyof {
                typeUrl?: string;
                value?: Uint8Array;
            }[]>, never>;
            Log?: string;
            Info?: string;
        } & Record<Exclude<keyof I_12, keyof _0.ResponseBase>, never>>(object: I_12): _0.ResponseBase;
    };
    ResponseException: {
        encode(message: _0.ResponseException, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.ResponseException;
        fromJSON(object: any): _0.ResponseException;
        toJSON(message: _0.ResponseException): unknown;
        fromPartial<I_13 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_13["ResponseBase"]["Error"], keyof _5.Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_13["ResponseBase"]["Events"][number], keyof _5.Any>, never>)[] & Record<Exclude<keyof I_13["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_13["ResponseBase"], keyof _0.ResponseBase>, never>;
        } & Record<Exclude<keyof I_13, "ResponseBase">, never>>(object: I_13): _0.ResponseException;
    };
    ResponseEcho: {
        encode(message: _0.ResponseEcho, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.ResponseEcho;
        fromJSON(object: any): _0.ResponseEcho;
        toJSON(message: _0.ResponseEcho): unknown;
        fromPartial<I_14 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
            Message?: string;
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_14["ResponseBase"]["Error"], keyof _5.Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_14["ResponseBase"]["Events"][number], keyof _5.Any>, never>)[] & Record<Exclude<keyof I_14["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_14["ResponseBase"], keyof _0.ResponseBase>, never>;
            Message?: string;
        } & Record<Exclude<keyof I_14, keyof _0.ResponseEcho>, never>>(object: I_14): _0.ResponseEcho;
    };
    ResponseFlush: {
        encode(message: _0.ResponseFlush, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.ResponseFlush;
        fromJSON(object: any): _0.ResponseFlush;
        toJSON(message: _0.ResponseFlush): unknown;
        fromPartial<I_15 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_15["ResponseBase"]["Error"], keyof _5.Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_15["ResponseBase"]["Events"][number], keyof _5.Any>, never>)[] & Record<Exclude<keyof I_15["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_15["ResponseBase"], keyof _0.ResponseBase>, never>;
        } & Record<Exclude<keyof I_15, "ResponseBase">, never>>(object: I_15): _0.ResponseFlush;
    };
    ResponseInfo: {
        encode(message: _0.ResponseInfo, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.ResponseInfo;
        fromJSON(object: any): _0.ResponseInfo;
        toJSON(message: _0.ResponseInfo): unknown;
        fromPartial<I_16 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
            ABCIVersion?: string;
            AppVersion?: string;
            LastBlockHeight?: string | number | import("long");
            LastBlockAppHash?: Uint8Array;
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_16["ResponseBase"]["Error"], keyof _5.Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_16["ResponseBase"]["Events"][number], keyof _5.Any>, never>)[] & Record<Exclude<keyof I_16["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_16["ResponseBase"], keyof _0.ResponseBase>, never>;
            ABCIVersion?: string;
            AppVersion?: string;
            LastBlockHeight?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_16["LastBlockHeight"], keyof import("long")>, never>);
            LastBlockAppHash?: Uint8Array;
        } & Record<Exclude<keyof I_16, keyof _0.ResponseInfo>, never>>(object: I_16): _0.ResponseInfo;
    };
    ResponseSetOption: {
        encode(message: _0.ResponseSetOption, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.ResponseSetOption;
        fromJSON(object: any): _0.ResponseSetOption;
        toJSON(message: _0.ResponseSetOption): unknown;
        fromPartial<I_17 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_17["ResponseBase"]["Error"], keyof _5.Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_17["ResponseBase"]["Events"][number], keyof _5.Any>, never>)[] & Record<Exclude<keyof I_17["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_17["ResponseBase"], keyof _0.ResponseBase>, never>;
        } & Record<Exclude<keyof I_17, "ResponseBase">, never>>(object: I_17): _0.ResponseSetOption;
    };
    ResponseInitChain: {
        encode(message: _0.ResponseInitChain, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.ResponseInitChain;
        fromJSON(object: any): _0.ResponseInitChain;
        toJSON(message: _0.ResponseInitChain): unknown;
        fromPartial<I_18 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
            ConsensusParams?: {
                Block?: {
                    MaxTxBytes?: string | number | import("long");
                    MaxDataBytes?: string | number | import("long");
                    MaxBlockBytes?: string | number | import("long");
                    MaxGas?: string | number | import("long");
                    TimeIotaMS?: string | number | import("long");
                };
                Validator?: {
                    PubKeyTypeURLs?: string[];
                };
            };
            Validators?: {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            }[];
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_18["ResponseBase"]["Error"], keyof _5.Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_18["ResponseBase"]["Events"][number], keyof _5.Any>, never>)[] & Record<Exclude<keyof I_18["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_18["ResponseBase"], keyof _0.ResponseBase>, never>;
            ConsensusParams?: {
                Block?: {
                    MaxTxBytes?: string | number | import("long");
                    MaxDataBytes?: string | number | import("long");
                    MaxBlockBytes?: string | number | import("long");
                    MaxGas?: string | number | import("long");
                    TimeIotaMS?: string | number | import("long");
                };
                Validator?: {
                    PubKeyTypeURLs?: string[];
                };
            } & {
                Block?: {
                    MaxTxBytes?: string | number | import("long");
                    MaxDataBytes?: string | number | import("long");
                    MaxBlockBytes?: string | number | import("long");
                    MaxGas?: string | number | import("long");
                    TimeIotaMS?: string | number | import("long");
                } & {
                    MaxTxBytes?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_18["ConsensusParams"]["Block"]["MaxTxBytes"], keyof import("long")>, never>);
                    MaxDataBytes?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_18["ConsensusParams"]["Block"]["MaxDataBytes"], keyof import("long")>, never>);
                    MaxBlockBytes?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_18["ConsensusParams"]["Block"]["MaxBlockBytes"], keyof import("long")>, never>);
                    MaxGas?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_18["ConsensusParams"]["Block"]["MaxGas"], keyof import("long")>, never>);
                    TimeIotaMS?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_18["ConsensusParams"]["Block"]["TimeIotaMS"], keyof import("long")>, never>);
                } & Record<Exclude<keyof I_18["ConsensusParams"]["Block"], keyof _0.BlockParams>, never>;
                Validator?: {
                    PubKeyTypeURLs?: string[];
                } & {
                    PubKeyTypeURLs?: string[] & string[] & Record<Exclude<keyof I_18["ConsensusParams"]["Validator"]["PubKeyTypeURLs"], keyof string[]>, never>;
                } & Record<Exclude<keyof I_18["ConsensusParams"]["Validator"], "PubKeyTypeURLs">, never>;
            } & Record<Exclude<keyof I_18["ConsensusParams"], keyof _0.ConsensusParams>, never>;
            Validators?: {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            }[] & ({
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            } & {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_18["Validators"][number]["PubKey"], keyof _5.Any>, never>;
                Power?: string | number | (import("long") & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long")) => import("long");
                    and: (other: string | number | import("long")) => import("long");
                    compare: (other: string | number | import("long")) => number;
                    comp: (other: string | number | import("long")) => number;
                    divide: (divisor: string | number | import("long")) => import("long");
                    div: (divisor: string | number | import("long")) => import("long");
                    equals: (other: string | number | import("long")) => boolean;
                    eq: (other: string | number | import("long")) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long")) => boolean;
                    gt: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                    gte: (other: string | number | import("long")) => boolean;
                    ge: (other: string | number | import("long")) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    eqz: () => boolean;
                    lessThan: (other: string | number | import("long")) => boolean;
                    lt: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual: (other: string | number | import("long")) => boolean;
                    lte: (other: string | number | import("long")) => boolean;
                    le: (other: string | number | import("long")) => boolean;
                    modulo: (other: string | number | import("long")) => import("long");
                    mod: (other: string | number | import("long")) => import("long");
                    rem: (other: string | number | import("long")) => import("long");
                    multiply: (multiplier: string | number | import("long")) => import("long");
                    mul: (multiplier: string | number | import("long")) => import("long");
                    negate: () => import("long");
                    neg: () => import("long");
                    not: () => import("long");
                    countLeadingZeros: () => number;
                    clz: () => number;
                    countTrailingZeros: () => number;
                    ctz: () => number;
                    notEquals: (other: string | number | import("long")) => boolean;
                    neq: (other: string | number | import("long")) => boolean;
                    ne: (other: string | number | import("long")) => boolean;
                    or: (other: string | number | import("long")) => import("long");
                    shiftLeft: (numBits: number | import("long")) => import("long");
                    shl: (numBits: number | import("long")) => import("long");
                    shiftRight: (numBits: number | import("long")) => import("long");
                    shr: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                    shru: (numBits: number | import("long")) => import("long");
                    shr_u: (numBits: number | import("long")) => import("long");
                    rotateLeft: (numBits: number | import("long")) => import("long");
                    rotl: (numBits: number | import("long")) => import("long");
                    rotateRight: (numBits: number | import("long")) => import("long");
                    rotr: (numBits: number | import("long")) => import("long");
                    subtract: (subtrahend: string | number | import("long")) => import("long");
                    sub: (subtrahend: string | number | import("long")) => import("long");
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long");
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long");
                    xor: (other: string | number | import("long")) => import("long");
                } & Record<Exclude<keyof I_18["Validators"][number]["Power"], keyof import("long")>, never>);
            } & Record<Exclude<keyof I_18["Validators"][number], keyof _0.ValidatorUpdate>, never>)[] & Record<Exclude<keyof I_18["Validators"], keyof {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            }[]>, never>;
        } & Record<Exclude<keyof I_18, keyof _0.ResponseInitChain>, never>>(object: I_18): _0.ResponseInitChain;
    };
    ResponseQuery: {
        encode(message: _0.ResponseQuery, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.ResponseQuery;
        fromJSON(object: any): _0.ResponseQuery;
        toJSON(message: _0.ResponseQuery): unknown;
        fromPartial<I_19 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
            Key?: Uint8Array;
            Value?: Uint8Array;
            Proof?: {
                Ops?: {
                    Type?: string;
                    Key?: Uint8Array;
                    Data?: Uint8Array;
                }[];
            };
            Height?: string | number | import("long");
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_19["ResponseBase"]["Error"], keyof _5.Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_19["ResponseBase"]["Events"][number], keyof _5.Any>, never>)[] & Record<Exclude<keyof I_19["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_19["ResponseBase"], keyof _0.ResponseBase>, never>;
            Key?: Uint8Array;
            Value?: Uint8Array;
            Proof?: {
                Ops?: {
                    Type?: string;
                    Key?: Uint8Array;
                    Data?: Uint8Array;
                }[];
            } & {
                Ops?: {
                    Type?: string;
                    Key?: Uint8Array;
                    Data?: Uint8Array;
                }[] & ({
                    Type?: string;
                    Key?: Uint8Array;
                    Data?: Uint8Array;
                } & {
                    Type?: string;
                    Key?: Uint8Array;
                    Data?: Uint8Array;
                } & Record<Exclude<keyof I_19["Proof"]["Ops"][number], keyof _2.ProofOp>, never>)[] & Record<Exclude<keyof I_19["Proof"]["Ops"], keyof {
                    Type?: string;
                    Key?: Uint8Array;
                    Data?: Uint8Array;
                }[]>, never>;
            } & Record<Exclude<keyof I_19["Proof"], "Ops">, never>;
            Height?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_19["Height"], keyof import("long")>, never>);
        } & Record<Exclude<keyof I_19, keyof _0.ResponseQuery>, never>>(object: I_19): _0.ResponseQuery;
    };
    ResponseBeginBlock: {
        encode(message: _0.ResponseBeginBlock, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.ResponseBeginBlock;
        fromJSON(object: any): _0.ResponseBeginBlock;
        toJSON(message: _0.ResponseBeginBlock): unknown;
        fromPartial<I_20 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_20["ResponseBase"]["Error"], keyof _5.Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_20["ResponseBase"]["Events"][number], keyof _5.Any>, never>)[] & Record<Exclude<keyof I_20["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_20["ResponseBase"], keyof _0.ResponseBase>, never>;
        } & Record<Exclude<keyof I_20, "ResponseBase">, never>>(object: I_20): _0.ResponseBeginBlock;
    };
    ResponseCheckTx: {
        encode(message: _0.ResponseCheckTx, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.ResponseCheckTx;
        fromJSON(object: any): _0.ResponseCheckTx;
        toJSON(message: _0.ResponseCheckTx): unknown;
        fromPartial<I_21 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
            GasWanted?: string | number | import("long");
            GasUsed?: string | number | import("long");
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_21["ResponseBase"]["Error"], keyof _5.Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_21["ResponseBase"]["Events"][number], keyof _5.Any>, never>)[] & Record<Exclude<keyof I_21["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_21["ResponseBase"], keyof _0.ResponseBase>, never>;
            GasWanted?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_21["GasWanted"], keyof import("long")>, never>);
            GasUsed?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_21["GasUsed"], keyof import("long")>, never>);
        } & Record<Exclude<keyof I_21, keyof _0.ResponseCheckTx>, never>>(object: I_21): _0.ResponseCheckTx;
    };
    ResponseDeliverTx: {
        encode(message: _0.ResponseDeliverTx, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.ResponseDeliverTx;
        fromJSON(object: any): _0.ResponseDeliverTx;
        toJSON(message: _0.ResponseDeliverTx): unknown;
        fromPartial<I_22 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
            GasWanted?: string | number | import("long");
            GasUsed?: string | number | import("long");
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_22["ResponseBase"]["Error"], keyof _5.Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_22["ResponseBase"]["Events"][number], keyof _5.Any>, never>)[] & Record<Exclude<keyof I_22["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_22["ResponseBase"], keyof _0.ResponseBase>, never>;
            GasWanted?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_22["GasWanted"], keyof import("long")>, never>);
            GasUsed?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_22["GasUsed"], keyof import("long")>, never>);
        } & Record<Exclude<keyof I_22, keyof _0.ResponseDeliverTx>, never>>(object: I_22): _0.ResponseDeliverTx;
    };
    ResponseEndBlock: {
        encode(message: _0.ResponseEndBlock, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.ResponseEndBlock;
        fromJSON(object: any): _0.ResponseEndBlock;
        toJSON(message: _0.ResponseEndBlock): unknown;
        fromPartial<I_23 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
            ValidatorUpdates?: {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            }[];
            ConsensusParams?: {
                Block?: {
                    MaxTxBytes?: string | number | import("long");
                    MaxDataBytes?: string | number | import("long");
                    MaxBlockBytes?: string | number | import("long");
                    MaxGas?: string | number | import("long");
                    TimeIotaMS?: string | number | import("long");
                };
                Validator?: {
                    PubKeyTypeURLs?: string[];
                };
            };
            Events?: {
                typeUrl?: string;
                value?: Uint8Array;
            }[];
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_23["ResponseBase"]["Error"], keyof _5.Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_23["ResponseBase"]["Events"][number], keyof _5.Any>, never>)[] & Record<Exclude<keyof I_23["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_23["ResponseBase"], keyof _0.ResponseBase>, never>;
            ValidatorUpdates?: {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            }[] & ({
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            } & {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_23["ValidatorUpdates"][number]["PubKey"], keyof _5.Any>, never>;
                Power?: string | number | (import("long") & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long")) => import("long");
                    and: (other: string | number | import("long")) => import("long");
                    compare: (other: string | number | import("long")) => number;
                    comp: (other: string | number | import("long")) => number;
                    divide: (divisor: string | number | import("long")) => import("long");
                    div: (divisor: string | number | import("long")) => import("long");
                    equals: (other: string | number | import("long")) => boolean;
                    eq: (other: string | number | import("long")) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long")) => boolean;
                    gt: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                    gte: (other: string | number | import("long")) => boolean;
                    ge: (other: string | number | import("long")) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    eqz: () => boolean;
                    lessThan: (other: string | number | import("long")) => boolean;
                    lt: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual: (other: string | number | import("long")) => boolean;
                    lte: (other: string | number | import("long")) => boolean;
                    le: (other: string | number | import("long")) => boolean;
                    modulo: (other: string | number | import("long")) => import("long");
                    mod: (other: string | number | import("long")) => import("long");
                    rem: (other: string | number | import("long")) => import("long");
                    multiply: (multiplier: string | number | import("long")) => import("long");
                    mul: (multiplier: string | number | import("long")) => import("long");
                    negate: () => import("long");
                    neg: () => import("long");
                    not: () => import("long");
                    countLeadingZeros: () => number;
                    clz: () => number;
                    countTrailingZeros: () => number;
                    ctz: () => number;
                    notEquals: (other: string | number | import("long")) => boolean;
                    neq: (other: string | number | import("long")) => boolean;
                    ne: (other: string | number | import("long")) => boolean;
                    or: (other: string | number | import("long")) => import("long");
                    shiftLeft: (numBits: number | import("long")) => import("long");
                    shl: (numBits: number | import("long")) => import("long");
                    shiftRight: (numBits: number | import("long")) => import("long");
                    shr: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                    shru: (numBits: number | import("long")) => import("long");
                    shr_u: (numBits: number | import("long")) => import("long");
                    rotateLeft: (numBits: number | import("long")) => import("long");
                    rotl: (numBits: number | import("long")) => import("long");
                    rotateRight: (numBits: number | import("long")) => import("long");
                    rotr: (numBits: number | import("long")) => import("long");
                    subtract: (subtrahend: string | number | import("long")) => import("long");
                    sub: (subtrahend: string | number | import("long")) => import("long");
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long");
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long");
                    xor: (other: string | number | import("long")) => import("long");
                } & Record<Exclude<keyof I_23["ValidatorUpdates"][number]["Power"], keyof import("long")>, never>);
            } & Record<Exclude<keyof I_23["ValidatorUpdates"][number], keyof _0.ValidatorUpdate>, never>)[] & Record<Exclude<keyof I_23["ValidatorUpdates"], keyof {
                Address?: string;
                PubKey?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Power?: string | number | import("long");
            }[]>, never>;
            ConsensusParams?: {
                Block?: {
                    MaxTxBytes?: string | number | import("long");
                    MaxDataBytes?: string | number | import("long");
                    MaxBlockBytes?: string | number | import("long");
                    MaxGas?: string | number | import("long");
                    TimeIotaMS?: string | number | import("long");
                };
                Validator?: {
                    PubKeyTypeURLs?: string[];
                };
            } & {
                Block?: {
                    MaxTxBytes?: string | number | import("long");
                    MaxDataBytes?: string | number | import("long");
                    MaxBlockBytes?: string | number | import("long");
                    MaxGas?: string | number | import("long");
                    TimeIotaMS?: string | number | import("long");
                } & {
                    MaxTxBytes?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_23["ConsensusParams"]["Block"]["MaxTxBytes"], keyof import("long")>, never>);
                    MaxDataBytes?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_23["ConsensusParams"]["Block"]["MaxDataBytes"], keyof import("long")>, never>);
                    MaxBlockBytes?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_23["ConsensusParams"]["Block"]["MaxBlockBytes"], keyof import("long")>, never>);
                    MaxGas?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_23["ConsensusParams"]["Block"]["MaxGas"], keyof import("long")>, never>);
                    TimeIotaMS?: string | number | (import("long") & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | import("long")) => import("long");
                        and: (other: string | number | import("long")) => import("long");
                        compare: (other: string | number | import("long")) => number;
                        comp: (other: string | number | import("long")) => number;
                        divide: (divisor: string | number | import("long")) => import("long");
                        div: (divisor: string | number | import("long")) => import("long");
                        equals: (other: string | number | import("long")) => boolean;
                        eq: (other: string | number | import("long")) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | import("long")) => boolean;
                        gt: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                        gte: (other: string | number | import("long")) => boolean;
                        ge: (other: string | number | import("long")) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        eqz: () => boolean;
                        lessThan: (other: string | number | import("long")) => boolean;
                        lt: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual: (other: string | number | import("long")) => boolean;
                        lte: (other: string | number | import("long")) => boolean;
                        le: (other: string | number | import("long")) => boolean;
                        modulo: (other: string | number | import("long")) => import("long");
                        mod: (other: string | number | import("long")) => import("long");
                        rem: (other: string | number | import("long")) => import("long");
                        multiply: (multiplier: string | number | import("long")) => import("long");
                        mul: (multiplier: string | number | import("long")) => import("long");
                        negate: () => import("long");
                        neg: () => import("long");
                        not: () => import("long");
                        countLeadingZeros: () => number;
                        clz: () => number;
                        countTrailingZeros: () => number;
                        ctz: () => number;
                        notEquals: (other: string | number | import("long")) => boolean;
                        neq: (other: string | number | import("long")) => boolean;
                        ne: (other: string | number | import("long")) => boolean;
                        or: (other: string | number | import("long")) => import("long");
                        shiftLeft: (numBits: number | import("long")) => import("long");
                        shl: (numBits: number | import("long")) => import("long");
                        shiftRight: (numBits: number | import("long")) => import("long");
                        shr: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                        shru: (numBits: number | import("long")) => import("long");
                        shr_u: (numBits: number | import("long")) => import("long");
                        rotateLeft: (numBits: number | import("long")) => import("long");
                        rotl: (numBits: number | import("long")) => import("long");
                        rotateRight: (numBits: number | import("long")) => import("long");
                        rotr: (numBits: number | import("long")) => import("long");
                        subtract: (subtrahend: string | number | import("long")) => import("long");
                        sub: (subtrahend: string | number | import("long")) => import("long");
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => import("long");
                        toString: (radix?: number) => string;
                        toUnsigned: () => import("long");
                        xor: (other: string | number | import("long")) => import("long");
                    } & Record<Exclude<keyof I_23["ConsensusParams"]["Block"]["TimeIotaMS"], keyof import("long")>, never>);
                } & Record<Exclude<keyof I_23["ConsensusParams"]["Block"], keyof _0.BlockParams>, never>;
                Validator?: {
                    PubKeyTypeURLs?: string[];
                } & {
                    PubKeyTypeURLs?: string[] & string[] & Record<Exclude<keyof I_23["ConsensusParams"]["Validator"]["PubKeyTypeURLs"], keyof string[]>, never>;
                } & Record<Exclude<keyof I_23["ConsensusParams"]["Validator"], "PubKeyTypeURLs">, never>;
            } & Record<Exclude<keyof I_23["ConsensusParams"], keyof _0.ConsensusParams>, never>;
            Events?: {
                typeUrl?: string;
                value?: Uint8Array;
            }[] & ({
                typeUrl?: string;
                value?: Uint8Array;
            } & {
                typeUrl?: string;
                value?: Uint8Array;
            } & Record<Exclude<keyof I_23["Events"][number], keyof _5.Any>, never>)[] & Record<Exclude<keyof I_23["Events"], keyof {
                typeUrl?: string;
                value?: Uint8Array;
            }[]>, never>;
        } & Record<Exclude<keyof I_23, keyof _0.ResponseEndBlock>, never>>(object: I_23): _0.ResponseEndBlock;
    };
    ResponseCommit: {
        encode(message: _0.ResponseCommit, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.ResponseCommit;
        fromJSON(object: any): _0.ResponseCommit;
        toJSON(message: _0.ResponseCommit): unknown;
        fromPartial<I_24 extends {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            };
        } & {
            ResponseBase?: {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                };
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[];
                Log?: string;
                Info?: string;
            } & {
                Error?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_24["ResponseBase"]["Error"], keyof _5.Any>, never>;
                Data?: Uint8Array;
                Events?: {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[] & ({
                    typeUrl?: string;
                    value?: Uint8Array;
                } & {
                    typeUrl?: string;
                    value?: Uint8Array;
                } & Record<Exclude<keyof I_24["ResponseBase"]["Events"][number], keyof _5.Any>, never>)[] & Record<Exclude<keyof I_24["ResponseBase"]["Events"], keyof {
                    typeUrl?: string;
                    value?: Uint8Array;
                }[]>, never>;
                Log?: string;
                Info?: string;
            } & Record<Exclude<keyof I_24["ResponseBase"], keyof _0.ResponseBase>, never>;
        } & Record<Exclude<keyof I_24, "ResponseBase">, never>>(object: I_24): _0.ResponseCommit;
    };
    StringError: {
        encode(message: _0.StringError, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.StringError;
        fromJSON(object: any): _0.StringError;
        toJSON(message: _0.StringError): unknown;
        fromPartial<I_25 extends {
            Value?: string;
        } & {
            Value?: string;
        } & Record<Exclude<keyof I_25, "Value">, never>>(object: I_25): _0.StringError;
    };
    ConsensusParams: {
        encode(message: _0.ConsensusParams, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.ConsensusParams;
        fromJSON(object: any): _0.ConsensusParams;
        toJSON(message: _0.ConsensusParams): unknown;
        fromPartial<I_26 extends {
            Block?: {
                MaxTxBytes?: string | number | import("long");
                MaxDataBytes?: string | number | import("long");
                MaxBlockBytes?: string | number | import("long");
                MaxGas?: string | number | import("long");
                TimeIotaMS?: string | number | import("long");
            };
            Validator?: {
                PubKeyTypeURLs?: string[];
            };
        } & {
            Block?: {
                MaxTxBytes?: string | number | import("long");
                MaxDataBytes?: string | number | import("long");
                MaxBlockBytes?: string | number | import("long");
                MaxGas?: string | number | import("long");
                TimeIotaMS?: string | number | import("long");
            } & {
                MaxTxBytes?: string | number | (import("long") & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long")) => import("long");
                    and: (other: string | number | import("long")) => import("long");
                    compare: (other: string | number | import("long")) => number;
                    comp: (other: string | number | import("long")) => number;
                    divide: (divisor: string | number | import("long")) => import("long");
                    div: (divisor: string | number | import("long")) => import("long");
                    equals: (other: string | number | import("long")) => boolean;
                    eq: (other: string | number | import("long")) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long")) => boolean;
                    gt: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                    gte: (other: string | number | import("long")) => boolean;
                    ge: (other: string | number | import("long")) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    eqz: () => boolean;
                    lessThan: (other: string | number | import("long")) => boolean;
                    lt: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual: (other: string | number | import("long")) => boolean;
                    lte: (other: string | number | import("long")) => boolean;
                    le: (other: string | number | import("long")) => boolean;
                    modulo: (other: string | number | import("long")) => import("long");
                    mod: (other: string | number | import("long")) => import("long");
                    rem: (other: string | number | import("long")) => import("long");
                    multiply: (multiplier: string | number | import("long")) => import("long");
                    mul: (multiplier: string | number | import("long")) => import("long");
                    negate: () => import("long");
                    neg: () => import("long");
                    not: () => import("long");
                    countLeadingZeros: () => number;
                    clz: () => number;
                    countTrailingZeros: () => number;
                    ctz: () => number;
                    notEquals: (other: string | number | import("long")) => boolean;
                    neq: (other: string | number | import("long")) => boolean;
                    ne: (other: string | number | import("long")) => boolean;
                    or: (other: string | number | import("long")) => import("long");
                    shiftLeft: (numBits: number | import("long")) => import("long");
                    shl: (numBits: number | import("long")) => import("long");
                    shiftRight: (numBits: number | import("long")) => import("long");
                    shr: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                    shru: (numBits: number | import("long")) => import("long");
                    shr_u: (numBits: number | import("long")) => import("long");
                    rotateLeft: (numBits: number | import("long")) => import("long");
                    rotl: (numBits: number | import("long")) => import("long");
                    rotateRight: (numBits: number | import("long")) => import("long");
                    rotr: (numBits: number | import("long")) => import("long");
                    subtract: (subtrahend: string | number | import("long")) => import("long");
                    sub: (subtrahend: string | number | import("long")) => import("long");
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long");
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long");
                    xor: (other: string | number | import("long")) => import("long");
                } & Record<Exclude<keyof I_26["Block"]["MaxTxBytes"], keyof import("long")>, never>);
                MaxDataBytes?: string | number | (import("long") & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long")) => import("long");
                    and: (other: string | number | import("long")) => import("long");
                    compare: (other: string | number | import("long")) => number;
                    comp: (other: string | number | import("long")) => number;
                    divide: (divisor: string | number | import("long")) => import("long");
                    div: (divisor: string | number | import("long")) => import("long");
                    equals: (other: string | number | import("long")) => boolean;
                    eq: (other: string | number | import("long")) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long")) => boolean;
                    gt: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                    gte: (other: string | number | import("long")) => boolean;
                    ge: (other: string | number | import("long")) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    eqz: () => boolean;
                    lessThan: (other: string | number | import("long")) => boolean;
                    lt: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual: (other: string | number | import("long")) => boolean;
                    lte: (other: string | number | import("long")) => boolean;
                    le: (other: string | number | import("long")) => boolean;
                    modulo: (other: string | number | import("long")) => import("long");
                    mod: (other: string | number | import("long")) => import("long");
                    rem: (other: string | number | import("long")) => import("long");
                    multiply: (multiplier: string | number | import("long")) => import("long");
                    mul: (multiplier: string | number | import("long")) => import("long");
                    negate: () => import("long");
                    neg: () => import("long");
                    not: () => import("long");
                    countLeadingZeros: () => number;
                    clz: () => number;
                    countTrailingZeros: () => number;
                    ctz: () => number;
                    notEquals: (other: string | number | import("long")) => boolean;
                    neq: (other: string | number | import("long")) => boolean;
                    ne: (other: string | number | import("long")) => boolean;
                    or: (other: string | number | import("long")) => import("long");
                    shiftLeft: (numBits: number | import("long")) => import("long");
                    shl: (numBits: number | import("long")) => import("long");
                    shiftRight: (numBits: number | import("long")) => import("long");
                    shr: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                    shru: (numBits: number | import("long")) => import("long");
                    shr_u: (numBits: number | import("long")) => import("long");
                    rotateLeft: (numBits: number | import("long")) => import("long");
                    rotl: (numBits: number | import("long")) => import("long");
                    rotateRight: (numBits: number | import("long")) => import("long");
                    rotr: (numBits: number | import("long")) => import("long");
                    subtract: (subtrahend: string | number | import("long")) => import("long");
                    sub: (subtrahend: string | number | import("long")) => import("long");
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long");
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long");
                    xor: (other: string | number | import("long")) => import("long");
                } & Record<Exclude<keyof I_26["Block"]["MaxDataBytes"], keyof import("long")>, never>);
                MaxBlockBytes?: string | number | (import("long") & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long")) => import("long");
                    and: (other: string | number | import("long")) => import("long");
                    compare: (other: string | number | import("long")) => number;
                    comp: (other: string | number | import("long")) => number;
                    divide: (divisor: string | number | import("long")) => import("long");
                    div: (divisor: string | number | import("long")) => import("long");
                    equals: (other: string | number | import("long")) => boolean;
                    eq: (other: string | number | import("long")) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long")) => boolean;
                    gt: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                    gte: (other: string | number | import("long")) => boolean;
                    ge: (other: string | number | import("long")) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    eqz: () => boolean;
                    lessThan: (other: string | number | import("long")) => boolean;
                    lt: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual: (other: string | number | import("long")) => boolean;
                    lte: (other: string | number | import("long")) => boolean;
                    le: (other: string | number | import("long")) => boolean;
                    modulo: (other: string | number | import("long")) => import("long");
                    mod: (other: string | number | import("long")) => import("long");
                    rem: (other: string | number | import("long")) => import("long");
                    multiply: (multiplier: string | number | import("long")) => import("long");
                    mul: (multiplier: string | number | import("long")) => import("long");
                    negate: () => import("long");
                    neg: () => import("long");
                    not: () => import("long");
                    countLeadingZeros: () => number;
                    clz: () => number;
                    countTrailingZeros: () => number;
                    ctz: () => number;
                    notEquals: (other: string | number | import("long")) => boolean;
                    neq: (other: string | number | import("long")) => boolean;
                    ne: (other: string | number | import("long")) => boolean;
                    or: (other: string | number | import("long")) => import("long");
                    shiftLeft: (numBits: number | import("long")) => import("long");
                    shl: (numBits: number | import("long")) => import("long");
                    shiftRight: (numBits: number | import("long")) => import("long");
                    shr: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                    shru: (numBits: number | import("long")) => import("long");
                    shr_u: (numBits: number | import("long")) => import("long");
                    rotateLeft: (numBits: number | import("long")) => import("long");
                    rotl: (numBits: number | import("long")) => import("long");
                    rotateRight: (numBits: number | import("long")) => import("long");
                    rotr: (numBits: number | import("long")) => import("long");
                    subtract: (subtrahend: string | number | import("long")) => import("long");
                    sub: (subtrahend: string | number | import("long")) => import("long");
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long");
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long");
                    xor: (other: string | number | import("long")) => import("long");
                } & Record<Exclude<keyof I_26["Block"]["MaxBlockBytes"], keyof import("long")>, never>);
                MaxGas?: string | number | (import("long") & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long")) => import("long");
                    and: (other: string | number | import("long")) => import("long");
                    compare: (other: string | number | import("long")) => number;
                    comp: (other: string | number | import("long")) => number;
                    divide: (divisor: string | number | import("long")) => import("long");
                    div: (divisor: string | number | import("long")) => import("long");
                    equals: (other: string | number | import("long")) => boolean;
                    eq: (other: string | number | import("long")) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long")) => boolean;
                    gt: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                    gte: (other: string | number | import("long")) => boolean;
                    ge: (other: string | number | import("long")) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    eqz: () => boolean;
                    lessThan: (other: string | number | import("long")) => boolean;
                    lt: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual: (other: string | number | import("long")) => boolean;
                    lte: (other: string | number | import("long")) => boolean;
                    le: (other: string | number | import("long")) => boolean;
                    modulo: (other: string | number | import("long")) => import("long");
                    mod: (other: string | number | import("long")) => import("long");
                    rem: (other: string | number | import("long")) => import("long");
                    multiply: (multiplier: string | number | import("long")) => import("long");
                    mul: (multiplier: string | number | import("long")) => import("long");
                    negate: () => import("long");
                    neg: () => import("long");
                    not: () => import("long");
                    countLeadingZeros: () => number;
                    clz: () => number;
                    countTrailingZeros: () => number;
                    ctz: () => number;
                    notEquals: (other: string | number | import("long")) => boolean;
                    neq: (other: string | number | import("long")) => boolean;
                    ne: (other: string | number | import("long")) => boolean;
                    or: (other: string | number | import("long")) => import("long");
                    shiftLeft: (numBits: number | import("long")) => import("long");
                    shl: (numBits: number | import("long")) => import("long");
                    shiftRight: (numBits: number | import("long")) => import("long");
                    shr: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                    shru: (numBits: number | import("long")) => import("long");
                    shr_u: (numBits: number | import("long")) => import("long");
                    rotateLeft: (numBits: number | import("long")) => import("long");
                    rotl: (numBits: number | import("long")) => import("long");
                    rotateRight: (numBits: number | import("long")) => import("long");
                    rotr: (numBits: number | import("long")) => import("long");
                    subtract: (subtrahend: string | number | import("long")) => import("long");
                    sub: (subtrahend: string | number | import("long")) => import("long");
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long");
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long");
                    xor: (other: string | number | import("long")) => import("long");
                } & Record<Exclude<keyof I_26["Block"]["MaxGas"], keyof import("long")>, never>);
                TimeIotaMS?: string | number | (import("long") & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long")) => import("long");
                    and: (other: string | number | import("long")) => import("long");
                    compare: (other: string | number | import("long")) => number;
                    comp: (other: string | number | import("long")) => number;
                    divide: (divisor: string | number | import("long")) => import("long");
                    div: (divisor: string | number | import("long")) => import("long");
                    equals: (other: string | number | import("long")) => boolean;
                    eq: (other: string | number | import("long")) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long")) => boolean;
                    gt: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                    gte: (other: string | number | import("long")) => boolean;
                    ge: (other: string | number | import("long")) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    eqz: () => boolean;
                    lessThan: (other: string | number | import("long")) => boolean;
                    lt: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual: (other: string | number | import("long")) => boolean;
                    lte: (other: string | number | import("long")) => boolean;
                    le: (other: string | number | import("long")) => boolean;
                    modulo: (other: string | number | import("long")) => import("long");
                    mod: (other: string | number | import("long")) => import("long");
                    rem: (other: string | number | import("long")) => import("long");
                    multiply: (multiplier: string | number | import("long")) => import("long");
                    mul: (multiplier: string | number | import("long")) => import("long");
                    negate: () => import("long");
                    neg: () => import("long");
                    not: () => import("long");
                    countLeadingZeros: () => number;
                    clz: () => number;
                    countTrailingZeros: () => number;
                    ctz: () => number;
                    notEquals: (other: string | number | import("long")) => boolean;
                    neq: (other: string | number | import("long")) => boolean;
                    ne: (other: string | number | import("long")) => boolean;
                    or: (other: string | number | import("long")) => import("long");
                    shiftLeft: (numBits: number | import("long")) => import("long");
                    shl: (numBits: number | import("long")) => import("long");
                    shiftRight: (numBits: number | import("long")) => import("long");
                    shr: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                    shru: (numBits: number | import("long")) => import("long");
                    shr_u: (numBits: number | import("long")) => import("long");
                    rotateLeft: (numBits: number | import("long")) => import("long");
                    rotl: (numBits: number | import("long")) => import("long");
                    rotateRight: (numBits: number | import("long")) => import("long");
                    rotr: (numBits: number | import("long")) => import("long");
                    subtract: (subtrahend: string | number | import("long")) => import("long");
                    sub: (subtrahend: string | number | import("long")) => import("long");
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long");
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long");
                    xor: (other: string | number | import("long")) => import("long");
                } & Record<Exclude<keyof I_26["Block"]["TimeIotaMS"], keyof import("long")>, never>);
            } & Record<Exclude<keyof I_26["Block"], keyof _0.BlockParams>, never>;
            Validator?: {
                PubKeyTypeURLs?: string[];
            } & {
                PubKeyTypeURLs?: string[] & string[] & Record<Exclude<keyof I_26["Validator"]["PubKeyTypeURLs"], keyof string[]>, never>;
            } & Record<Exclude<keyof I_26["Validator"], "PubKeyTypeURLs">, never>;
        } & Record<Exclude<keyof I_26, keyof _0.ConsensusParams>, never>>(object: I_26): _0.ConsensusParams;
    };
    BlockParams: {
        encode(message: _0.BlockParams, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.BlockParams;
        fromJSON(object: any): _0.BlockParams;
        toJSON(message: _0.BlockParams): unknown;
        fromPartial<I_27 extends {
            MaxTxBytes?: string | number | import("long");
            MaxDataBytes?: string | number | import("long");
            MaxBlockBytes?: string | number | import("long");
            MaxGas?: string | number | import("long");
            TimeIotaMS?: string | number | import("long");
        } & {
            MaxTxBytes?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_27["MaxTxBytes"], keyof import("long")>, never>);
            MaxDataBytes?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_27["MaxDataBytes"], keyof import("long")>, never>);
            MaxBlockBytes?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_27["MaxBlockBytes"], keyof import("long")>, never>);
            MaxGas?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_27["MaxGas"], keyof import("long")>, never>);
            TimeIotaMS?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_27["TimeIotaMS"], keyof import("long")>, never>);
        } & Record<Exclude<keyof I_27, keyof _0.BlockParams>, never>>(object: I_27): _0.BlockParams;
    };
    ValidatorParams: {
        encode(message: _0.ValidatorParams, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.ValidatorParams;
        fromJSON(object: any): _0.ValidatorParams;
        toJSON(message: _0.ValidatorParams): unknown;
        fromPartial<I_28 extends {
            PubKeyTypeURLs?: string[];
        } & {
            PubKeyTypeURLs?: string[] & string[] & Record<Exclude<keyof I_28["PubKeyTypeURLs"], keyof string[]>, never>;
        } & Record<Exclude<keyof I_28, "PubKeyTypeURLs">, never>>(object: I_28): _0.ValidatorParams;
    };
    ValidatorUpdate: {
        encode(message: _0.ValidatorUpdate, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.ValidatorUpdate;
        fromJSON(object: any): _0.ValidatorUpdate;
        toJSON(message: _0.ValidatorUpdate): unknown;
        fromPartial<I_29 extends {
            Address?: string;
            PubKey?: {
                typeUrl?: string;
                value?: Uint8Array;
            };
            Power?: string | number | import("long");
        } & {
            Address?: string;
            PubKey?: {
                typeUrl?: string;
                value?: Uint8Array;
            } & {
                typeUrl?: string;
                value?: Uint8Array;
            } & Record<Exclude<keyof I_29["PubKey"], keyof _5.Any>, never>;
            Power?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_29["Power"], keyof import("long")>, never>);
        } & Record<Exclude<keyof I_29, keyof _0.ValidatorUpdate>, never>>(object: I_29): _0.ValidatorUpdate;
    };
    LastCommitInfo: {
        encode(message: _0.LastCommitInfo, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.LastCommitInfo;
        fromJSON(object: any): _0.LastCommitInfo;
        toJSON(message: _0.LastCommitInfo): unknown;
        fromPartial<I_30 extends {
            Round?: number;
            Votes?: {
                Address?: string;
                Power?: string | number | import("long");
                SignedLastBlock?: boolean;
            }[];
        } & {
            Round?: number;
            Votes?: {
                Address?: string;
                Power?: string | number | import("long");
                SignedLastBlock?: boolean;
            }[] & ({
                Address?: string;
                Power?: string | number | import("long");
                SignedLastBlock?: boolean;
            } & {
                Address?: string;
                Power?: string | number | (import("long") & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long")) => import("long");
                    and: (other: string | number | import("long")) => import("long");
                    compare: (other: string | number | import("long")) => number;
                    comp: (other: string | number | import("long")) => number;
                    divide: (divisor: string | number | import("long")) => import("long");
                    div: (divisor: string | number | import("long")) => import("long");
                    equals: (other: string | number | import("long")) => boolean;
                    eq: (other: string | number | import("long")) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long")) => boolean;
                    gt: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                    gte: (other: string | number | import("long")) => boolean;
                    ge: (other: string | number | import("long")) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    eqz: () => boolean;
                    lessThan: (other: string | number | import("long")) => boolean;
                    lt: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual: (other: string | number | import("long")) => boolean;
                    lte: (other: string | number | import("long")) => boolean;
                    le: (other: string | number | import("long")) => boolean;
                    modulo: (other: string | number | import("long")) => import("long");
                    mod: (other: string | number | import("long")) => import("long");
                    rem: (other: string | number | import("long")) => import("long");
                    multiply: (multiplier: string | number | import("long")) => import("long");
                    mul: (multiplier: string | number | import("long")) => import("long");
                    negate: () => import("long");
                    neg: () => import("long");
                    not: () => import("long");
                    countLeadingZeros: () => number;
                    clz: () => number;
                    countTrailingZeros: () => number;
                    ctz: () => number;
                    notEquals: (other: string | number | import("long")) => boolean;
                    neq: (other: string | number | import("long")) => boolean;
                    ne: (other: string | number | import("long")) => boolean;
                    or: (other: string | number | import("long")) => import("long");
                    shiftLeft: (numBits: number | import("long")) => import("long");
                    shl: (numBits: number | import("long")) => import("long");
                    shiftRight: (numBits: number | import("long")) => import("long");
                    shr: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                    shru: (numBits: number | import("long")) => import("long");
                    shr_u: (numBits: number | import("long")) => import("long");
                    rotateLeft: (numBits: number | import("long")) => import("long");
                    rotl: (numBits: number | import("long")) => import("long");
                    rotateRight: (numBits: number | import("long")) => import("long");
                    rotr: (numBits: number | import("long")) => import("long");
                    subtract: (subtrahend: string | number | import("long")) => import("long");
                    sub: (subtrahend: string | number | import("long")) => import("long");
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long");
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long");
                    xor: (other: string | number | import("long")) => import("long");
                } & Record<Exclude<keyof I_30["Votes"][number]["Power"], keyof import("long")>, never>);
                SignedLastBlock?: boolean;
            } & Record<Exclude<keyof I_30["Votes"][number], keyof _0.VoteInfo>, never>)[] & Record<Exclude<keyof I_30["Votes"], keyof {
                Address?: string;
                Power?: string | number | import("long");
                SignedLastBlock?: boolean;
            }[]>, never>;
        } & Record<Exclude<keyof I_30, keyof _0.LastCommitInfo>, never>>(object: I_30): _0.LastCommitInfo;
    };
    VoteInfo: {
        encode(message: _0.VoteInfo, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.VoteInfo;
        fromJSON(object: any): _0.VoteInfo;
        toJSON(message: _0.VoteInfo): unknown;
        fromPartial<I_31 extends {
            Address?: string;
            Power?: string | number | import("long");
            SignedLastBlock?: boolean;
        } & {
            Address?: string;
            Power?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_31["Power"], keyof import("long")>, never>);
            SignedLastBlock?: boolean;
        } & Record<Exclude<keyof I_31, keyof _0.VoteInfo>, never>>(object: I_31): _0.VoteInfo;
    };
    EventString: {
        encode(message: _0.EventString, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.EventString;
        fromJSON(object: any): _0.EventString;
        toJSON(message: _0.EventString): unknown;
        fromPartial<I_32 extends {
            Value?: string;
        } & {
            Value?: string;
        } & Record<Exclude<keyof I_32, "Value">, never>>(object: I_32): _0.EventString;
    };
    MockHeader: {
        encode(message: _0.MockHeader, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _0.MockHeader;
        fromJSON(object: any): _0.MockHeader;
        toJSON(message: _0.MockHeader): unknown;
        fromPartial<I_33 extends {
            Version?: string;
            ChainID?: string;
            Height?: string | number | import("long");
            Time?: Date;
            NumTxs?: string | number | import("long");
            TotalTxs?: string | number | import("long");
        } & {
            Version?: string;
            ChainID?: string;
            Height?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_33["Height"], keyof import("long")>, never>);
            Time?: Date;
            NumTxs?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_33["NumTxs"], keyof import("long")>, never>);
            TotalTxs?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_33["TotalTxs"], keyof import("long")>, never>);
        } & Record<Exclude<keyof I_33, keyof _0.MockHeader>, never>>(object: I_33): _0.MockHeader;
    };
};
export declare const tm: {
    PubKeySecp256k1: {
        encode(message: _4.PubKeySecp256k1, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _4.PubKeySecp256k1;
        fromJSON(object: any): _4.PubKeySecp256k1;
        toJSON(message: _4.PubKeySecp256k1): unknown;
        fromPartial<I extends {
            Value?: Uint8Array;
        } & {
            Value?: Uint8Array;
        } & Record<Exclude<keyof I, "Value">, never>>(object: I): _4.PubKeySecp256k1;
    };
    PrivKeySecp256k1: {
        encode(message: _4.PrivKeySecp256k1, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _4.PrivKeySecp256k1;
        fromJSON(object: any): _4.PrivKeySecp256k1;
        toJSON(message: _4.PrivKeySecp256k1): unknown;
        fromPartial<I_1 extends {
            Value?: Uint8Array;
        } & {
            Value?: Uint8Array;
        } & Record<Exclude<keyof I_1, "Value">, never>>(object: I_1): _4.PrivKeySecp256k1;
    };
    PubKeyMultisig: {
        encode(message: _3.PubKeyMultisig, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _3.PubKeyMultisig;
        fromJSON(object: any): _3.PubKeyMultisig;
        toJSON(message: _3.PubKeyMultisig): unknown;
        fromPartial<I_2 extends {
            K?: string | number | import("long");
            PubKeys?: {
                typeUrl?: string;
                value?: Uint8Array;
            }[];
        } & {
            K?: string | number | (import("long") & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long")) => import("long");
                and: (other: string | number | import("long")) => import("long");
                compare: (other: string | number | import("long")) => number;
                comp: (other: string | number | import("long")) => number;
                divide: (divisor: string | number | import("long")) => import("long");
                div: (divisor: string | number | import("long")) => import("long");
                equals: (other: string | number | import("long")) => boolean;
                eq: (other: string | number | import("long")) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long")) => boolean;
                gt: (other: string | number | import("long")) => boolean;
                greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                gte: (other: string | number | import("long")) => boolean;
                ge: (other: string | number | import("long")) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | import("long")) => boolean;
                lt: (other: string | number | import("long")) => boolean;
                lessThanOrEqual: (other: string | number | import("long")) => boolean;
                lte: (other: string | number | import("long")) => boolean;
                le: (other: string | number | import("long")) => boolean;
                modulo: (other: string | number | import("long")) => import("long");
                mod: (other: string | number | import("long")) => import("long");
                rem: (other: string | number | import("long")) => import("long");
                multiply: (multiplier: string | number | import("long")) => import("long");
                mul: (multiplier: string | number | import("long")) => import("long");
                negate: () => import("long");
                neg: () => import("long");
                not: () => import("long");
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | import("long")) => boolean;
                neq: (other: string | number | import("long")) => boolean;
                ne: (other: string | number | import("long")) => boolean;
                or: (other: string | number | import("long")) => import("long");
                shiftLeft: (numBits: number | import("long")) => import("long");
                shl: (numBits: number | import("long")) => import("long");
                shiftRight: (numBits: number | import("long")) => import("long");
                shr: (numBits: number | import("long")) => import("long");
                shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                shru: (numBits: number | import("long")) => import("long");
                shr_u: (numBits: number | import("long")) => import("long");
                rotateLeft: (numBits: number | import("long")) => import("long");
                rotl: (numBits: number | import("long")) => import("long");
                rotateRight: (numBits: number | import("long")) => import("long");
                rotr: (numBits: number | import("long")) => import("long");
                subtract: (subtrahend: string | number | import("long")) => import("long");
                sub: (subtrahend: string | number | import("long")) => import("long");
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long");
                toString: (radix?: number) => string;
                toUnsigned: () => import("long");
                xor: (other: string | number | import("long")) => import("long");
            } & Record<Exclude<keyof I_2["K"], keyof import("long")>, never>);
            PubKeys?: {
                typeUrl?: string;
                value?: Uint8Array;
            }[] & ({
                typeUrl?: string;
                value?: Uint8Array;
            } & {
                typeUrl?: string;
                value?: Uint8Array;
            } & Record<Exclude<keyof I_2["PubKeys"][number], keyof _5.Any>, never>)[] & Record<Exclude<keyof I_2["PubKeys"], keyof {
                typeUrl?: string;
                value?: Uint8Array;
            }[]>, never>;
        } & Record<Exclude<keyof I_2, keyof _3.PubKeyMultisig>, never>>(object: I_2): _3.PubKeyMultisig;
    };
    ProofOp: {
        encode(message: _2.ProofOp, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _2.ProofOp;
        fromJSON(object: any): _2.ProofOp;
        toJSON(message: _2.ProofOp): unknown;
        fromPartial<I_3 extends {
            Type?: string;
            Key?: Uint8Array;
            Data?: Uint8Array;
        } & {
            Type?: string;
            Key?: Uint8Array;
            Data?: Uint8Array;
        } & Record<Exclude<keyof I_3, keyof _2.ProofOp>, never>>(object: I_3): _2.ProofOp;
    };
    Proof: {
        encode(message: _2.Proof, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _2.Proof;
        fromJSON(object: any): _2.Proof;
        toJSON(message: _2.Proof): unknown;
        fromPartial<I_4 extends {
            Ops?: {
                Type?: string;
                Key?: Uint8Array;
                Data?: Uint8Array;
            }[];
        } & {
            Ops?: {
                Type?: string;
                Key?: Uint8Array;
                Data?: Uint8Array;
            }[] & ({
                Type?: string;
                Key?: Uint8Array;
                Data?: Uint8Array;
            } & {
                Type?: string;
                Key?: Uint8Array;
                Data?: Uint8Array;
            } & Record<Exclude<keyof I_4["Ops"][number], keyof _2.ProofOp>, never>)[] & Record<Exclude<keyof I_4["Ops"], keyof {
                Type?: string;
                Key?: Uint8Array;
                Data?: Uint8Array;
            }[]>, never>;
        } & Record<Exclude<keyof I_4, "Ops">, never>>(object: I_4): _2.Proof;
    };
    PubKeyEd25519: {
        encode(message: _1.PubKeyEd25519, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _1.PubKeyEd25519;
        fromJSON(object: any): _1.PubKeyEd25519;
        toJSON(message: _1.PubKeyEd25519): unknown;
        fromPartial<I_5 extends {
            Value?: Uint8Array;
        } & {
            Value?: Uint8Array;
        } & Record<Exclude<keyof I_5, "Value">, never>>(object: I_5): _1.PubKeyEd25519;
    };
    PrivKeyEd25519: {
        encode(message: _1.PrivKeyEd25519, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
        decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _1.PrivKeyEd25519;
        fromJSON(object: any): _1.PrivKeyEd25519;
        toJSON(message: _1.PrivKeyEd25519): unknown;
        fromPartial<I_6 extends {
            Value?: Uint8Array;
        } & {
            Value?: Uint8Array;
        } & Record<Exclude<keyof I_6, "Value">, never>>(object: I_6): _1.PrivKeyEd25519;
    };
};
export declare namespace google {
    const protobuf: {
        Timestamp: {
            encode(message: _6.Timestamp, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _6.Timestamp;
            fromJSON(object: any): _6.Timestamp;
            toJSON(message: _6.Timestamp): unknown;
            fromPartial<I extends {
                seconds?: string | number | import("long");
                nanos?: number;
            } & {
                seconds?: string | number | (import("long") & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long")) => import("long");
                    and: (other: string | number | import("long")) => import("long");
                    compare: (other: string | number | import("long")) => number;
                    comp: (other: string | number | import("long")) => number;
                    divide: (divisor: string | number | import("long")) => import("long");
                    div: (divisor: string | number | import("long")) => import("long");
                    equals: (other: string | number | import("long")) => boolean;
                    eq: (other: string | number | import("long")) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long")) => boolean;
                    gt: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long")) => boolean;
                    gte: (other: string | number | import("long")) => boolean;
                    ge: (other: string | number | import("long")) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    eqz: () => boolean;
                    lessThan: (other: string | number | import("long")) => boolean;
                    lt: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual: (other: string | number | import("long")) => boolean;
                    lte: (other: string | number | import("long")) => boolean;
                    le: (other: string | number | import("long")) => boolean;
                    modulo: (other: string | number | import("long")) => import("long");
                    mod: (other: string | number | import("long")) => import("long");
                    rem: (other: string | number | import("long")) => import("long");
                    multiply: (multiplier: string | number | import("long")) => import("long");
                    mul: (multiplier: string | number | import("long")) => import("long");
                    negate: () => import("long");
                    neg: () => import("long");
                    not: () => import("long");
                    countLeadingZeros: () => number;
                    clz: () => number;
                    countTrailingZeros: () => number;
                    ctz: () => number;
                    notEquals: (other: string | number | import("long")) => boolean;
                    neq: (other: string | number | import("long")) => boolean;
                    ne: (other: string | number | import("long")) => boolean;
                    or: (other: string | number | import("long")) => import("long");
                    shiftLeft: (numBits: number | import("long")) => import("long");
                    shl: (numBits: number | import("long")) => import("long");
                    shiftRight: (numBits: number | import("long")) => import("long");
                    shr: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned: (numBits: number | import("long")) => import("long");
                    shru: (numBits: number | import("long")) => import("long");
                    shr_u: (numBits: number | import("long")) => import("long");
                    rotateLeft: (numBits: number | import("long")) => import("long");
                    rotl: (numBits: number | import("long")) => import("long");
                    rotateRight: (numBits: number | import("long")) => import("long");
                    rotr: (numBits: number | import("long")) => import("long");
                    subtract: (subtrahend: string | number | import("long")) => import("long");
                    sub: (subtrahend: string | number | import("long")) => import("long");
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long");
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long");
                    xor: (other: string | number | import("long")) => import("long");
                } & Record<Exclude<keyof I["seconds"], keyof import("long")>, never>);
                nanos?: number;
            } & Record<Exclude<keyof I, keyof _6.Timestamp>, never>>(object: I): _6.Timestamp;
        };
        Any: {
            encode(message: _5.Any, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _5.Any;
            fromJSON(object: any): _5.Any;
            toJSON(message: _5.Any): unknown;
            fromPartial<I_1 extends {
                typeUrl?: string;
                value?: Uint8Array;
            } & {
                typeUrl?: string;
                value?: Uint8Array;
            } & Record<Exclude<keyof I_1, keyof _5.Any>, never>>(object: I_1): _5.Any;
        };
    };
}
